         IFEQ  SYSTYPE

SYSTYPE  set   1

********************************************************************
* SysType - CoCo OS-9 System Specific Definitions
*
* $Id$
*
* Edt/Rev  YYYY/MM/DD  Modified by
* Comment
* ------------------------------------------------------------------
*          1998/10/13  Boisy G. Pitre
* Added defs by Bruce Isted from his Eliminator archive.
*
*          1998/10/31  Boisy G. Pitre
* Merged cc3global.defs into this file.
*
*          2002/04/30  Boisy G. Pitre
* Merged Level One and Level Two sysdefs.


         nam   SysType
         IFEQ  Level-1
         ttl   CoCo OS-9 Level One System Type Definitions
         ENDC
         IFEQ  Level-2
         ifne  NitrOS9
         ttl   CoCo NitrOS-9 Level Two System Type Definitions
         ELSE
         ttl   CoCo OS-9 Level Two System Type Definitions
         ENDC
         ENDC


**********************
* CPU Type Definitions
*
Color    set   1
Color3   set   2
         IFEQ  Level-1
CPUType  set   Color
         ELSE
CPUType  set   Color3
         ENDC


******************************
* Clock Speed Type Definitions
*
OneMHz   equ   1
TwoMHz   equ   2
         IFEQ  CPUType-Color
CPUSpeed set   OneMHz
         ELSE
CPUSpeed set   TwoMHz
         ENDC


**********************************
* Power Line Frequency Definitions
*
Hz50     equ   1          Assemble clock for 50 hz power
Hz60     equ   2          Assemble clock for 60 hz power
PwrLnFrq set   Hz60       Set to Appropriate freq


**********************************
* Ticks per second
*
         IFEQ  PwrLnFrq-Hz50
TkPerSec equ   50
         ELSE
TkPerSec equ   60
         ENDC


******************
* ACIA type set up
*
         org   1
ACIA6850 rmb   1          MC6850 acia.
ACIA6551 rmb   1          SY6551 acia.
ACIA2661 rmb   1          SC2661 acia.
ACIATYPE set   ACIA6551


****************************************
* Special character Bit position equates
*
SHIFTBIT equ   %00000001
CNTRLBIT equ   %00000010
ALTERBIT equ   %00000100
UPBIT    equ   %00001000
DOWNBIT  equ   %00010000
LEFTBIT  equ   %00100000
RIGHTBIT equ   %01000000
SPACEBIT equ   %10000000


******************
* Device addresses
*
A.AciaP  set   $FF68      Aciapak Address
A.ModP   set   $FF6C      ModPak Address
DPort    set   $FF40      Disk controller base address
MPI.Slct set   $FF7F      Multi-Pak slot select
MPI.Slot set   $03        Multi-Pak default slot
PIA0Base equ   $FF00
PIA.U4   equ   PIA0Base
PIA1Base equ   $FF20
PIA.U8   equ   PIA1Base

******************
* VDG Devices
*
A.TermV  set   $FFC0      VDG Term
A.V1     set   $FFC1      Possible additional VDG Devices
A.V2     set   $FFC2
A.V3     set   $FFC3
A.V4     set   $FFC4
A.V5     set   $FFC5
A.V6     set   $FFC6
A.V7     set   $FFC7


         IFEQ  Level-1

*************************************************
*
* OS-9 Level One CoCo 1/2 Section
*
*************************************************

HW.Page  set   $FF        Device descriptor hardware page
BTStart  set   $EF00      Boot track memory start

         ELSE

*************************************************
*
* OS-9 Level Two CoCo 3 Section
*
*************************************************

****************************************
* Dynamic Address Translator Definitions
*
DAT.BlCt equ   8          D.A.T. blocks/address space
DAT.BlSz equ   (256/DAT.BlCt)*256 D.A.T. block size
DAT.ImSz equ   DAT.BlCt*2 D.A.T. Image size
DAT.Addr equ   -(DAT.BlSz/256) D.A.T. MSB Address bits
DAT.Task equ   $FF91      Task Register address
DAT.TkCt equ   32         Number of DAT Tasks
DAT.Regs equ   $FFA0      DAT Block Registers base address
DAT.Free equ   $333E      Free Block Number
DAT.BlMx equ   $3F        Maximum Block number
DAT.BMSz equ   $40        Memory Block Map size
DAT.WrPr equ   0          no write protect
DAT.WrEn equ   0          no write enable
SysTask  equ   0          Coco System Task number
IOBlock  equ   $3F
ROMBlock equ   $3F
IOAddr   equ   $7F
ROMCount equ   1          number of blocks of ROM (High RAM Block)
RAMCount equ   1          initial blocks of RAM
MoveBlks equ   DAT.BlCt-ROMCount-2 Block numbers used for copies
BlockTyp equ   1          chk only first bytes of RAM block
ByteType equ   2          chk entire block of RAM
Limited  equ   1          chk only upper memory for ROM modules
UnLimitd equ   2          chk all NotRAM for modules
* NOTE: this check assumes any NotRAM with a module will
*       always start with $87CD in first two bytes of block
RAMCheck equ   BlockTyp   chk only beg bytes of block
ROMCheck equ   Limited    chk only upper few blocks for ROM
LastRAM  equ   IOBlock    maximum RAM block number

***************************
* Color Computer 3 Specific
*
CPUType  set   Color3
CPUSpeed set   TwoMHz
MappedIO equ   True       (Actually False but it works better this way)

********************
* Hardware addresses
*
GIMERegs equ   $FF00      Base address of GIME registers
IrqEnR   equ   $FF92      GIME IRQ enable/status register
BordReg  equ   $FF9A      Border color register
PalAdr   equ   $FFB0      Palette registers

HW.Page  set   $07        Device descriptor hardware page

*
* Window Devices
*
         org   $FF9F
A.W      rmb   1          $FF9F Generic Window Descriptor
A.TermW  rmb   1          $FFA0 Windowing Term
A.W1     rmb   1          $FFA1
A.W2     rmb   1          $FFA2
A.W3     rmb   1          $FFA3
A.W4     rmb   1          $FFA4
A.W5     rmb   1          $FFA5
A.W6     rmb   1          $FFA6
A.W7     rmb   1          $FFA7
A.W8     rmb   1          $FFA8
A.W9     rmb   1          $FFA9
A.W10    rmb   1          $FFAA
A.W11    rmb   1          $FFAB
A.W12    rmb   1          $FFAC
A.W13    rmb   1          $FFAD
A.W14    rmb   1          $FFAE
A.W15    rmb   1          $FFAF

**********************************
* Pointer Device Packet Definition
*
         org   0
Pt.Valid rmb   1          Is returned info valid (0=no/1=yes)
Pt.Actv  rmb   1          Active Side 0=off/1=Right/2=left
Pt.ToTm  rmb   1          Time out Initial value
         rmb   2          reserved
Pt.TTTo  rmb   1          Time Till Timeout
Pt.TSSt  rmb   2          Time Since Start Counter
Pt.CBSA  rmb   1          Current Button State Button A
Pt.CBSB  rmb   1          Current Button State Button B
Pt.CCtA  rmb   1          Click Count Button A
Pt.CCtB  rmb   1          Click Count Button B
Pt.TTSA  rmb   1          Time This State Counter Button A
Pt.TTSB  rmb   1          Time This State Counter Button B
Pt.TLSA  rmb   1          Time Last State Counter Button A
Pt.TLSB  rmb   1          Time Last State Counter Button B
         rmb   2          Reserved
Pt.BDX   rmb   2          Button down X value EXPERIMENTAL
Pt.BDY   rmb   2          Button down Y value
Pt.Stat  rmb   1          Window Pointer type location
Pt.Res   rmb   1          Resolution (0..640 by: 0=ten/1=one)
Pt.AcX   rmb   2          Actual X Value
Pt.AcY   rmb   2          Actual Y Value
Pt.WRX   rmb   2          Window Relative X
Pt.WRY   rmb   2          Window Relative Y
Pt.Siz   equ   .          Packet Size 32 bytes

**************************
* window regions for mouse
*
WR.Cntnt equ   0          content region
WR.Cntrl equ   1          control region
WR.OfWin equ   2          off window

*************************************
* Standard system get/put buffer defs
*
*
* system group numbers
*
         org   200
Grp.Fnt  rmb   1          font group
Grp.Clip rmb   1          clipboard group
Grp.Ptr  rmb   1          pointer group
Grp.Pat2 rmb   1          pattern group 2 color
Grp.Pat4 rmb   1          pattern group 4 color
Grp.Pat6 rmb   1          pattern group 16 color
*
* font buffer numbers
*
         org   1
Fnt.S8x8 rmb   1          standard 8x8 font
Fnt.S6x8 rmb   1          standard 6x8 font
Fnt.G8x8 rmb   1          standard graphics 8x8 font
*
* pattern buffer numbers
*
         org   1
Pat.Dot  rmb   1
Pat.Vrt  rmb   1
Pat.Hrz  rmb   1
Pat.XHtc rmb   1
Pat.LSnt rmb   1
Pat.RSnt rmb   1
Pat.SDot rmb   1
Pat.BDot rmb   1
*
* pointer buffer numbers
*
         org   1
Ptr.Arr  rmb   1          Arrow pointer
Ptr.Pen  rmb   1          Pencil pointer
Ptr.LCH  rmb   1          Large cross hair pointer
Ptr.Slp  rmb   1          Wait timer pointer
Ptr.Ill  rmb   1          Illegal action pointer
Ptr.Txt  rmb   1          Text pointer
Ptr.SCH  rmb   1          Small cross hair pointer

********************************
* Window/Menu Bar Data Structure
*
* To be used in SS.WnSet SETSTAT to set up a Framed Window
* for use in the high level windowing package.
*
NUMMENS  equ   10         maximum number of menus on menu bar
NUMITMS  equ   20         maximum number of items in a menu
MXTTLEN  equ   15         max chars for menu and item names
WINSYNC  equ   $C0C0      synch bytes for window validation
*
* Menu Item Descriptor : (MN.ITEMS)
* one required for each item within the menu
*
         org   0
MI.TTL   rmb   MXTTLEN    item name
MI.ENBL  rmb   1          enable flag
MI.RES   rmb   5          reserved bytes
MI.SIZ   equ   .          size of menu item descriptor
*
* Menu Descriptor :
* one for each menu on the manu bar
* each is pointed to by MB.MPTR below
*
         org   0
MN.TTL   rmb   MXTTLEN    menu title
MN.ID    rmb   1          menu id number (1-255)
MN.XSIZ  rmb   1          horiz. size of desired pull down
MN.NITS  rmb   1          number of items in menu
MN.ENBL  rmb   1          enable flag
MN.RES   rmb   2          reserved bytes
MN.ITEMS rmb   2          pointer to array of menu items
MN.SIZ   equ   .          size of menu descriptor
*
* Window Descriptor:
* one required for each application in a framed window
*
         org   0
WN.TTL   rmb   20         title of window for title bar
WN.NMNS  rmb   1          number of menus in menu bar
WN.XMIN  rmb   1          minimal horiz. size for application to run
WN.YMIN  rmb   1          minimal vert. size for application to run
WN.SYNC  rmb   2          synch bytes ($C0C0)
WN.RES   rmb   7          reserved bytes
WN.BAR   rmb   2          pointer to arry of menu descriptors
WN.SIZ   equ   .          size of window/menu bar descriptor

*************************
* Window Type Definitions
*
* To be used in setting up the border of the window in
* the SS.WnSel SETSTAT
*
         org   0
WT.NBox  rmb   1          No Box
WT.FWin  rmb   1          Framed Window
WT.FSWin rmb   1          Framed Window w/Scroll Bars
WT.SBox  rmb   1          Shadowed Box
WT.DBox  rmb   1          Double Box
WT.PBox  rmb   1          Plain Box

*************************************
* Pre-Defined Menu IDs for the system
*
         org   1
MId.Mov  rmb   1          move box
MId.Cls  rmb   1          close box
MId.Grw  rmb   1          grow box
MId.SUp  rmb   1          scroll up
MId.SDn  rmb   1          scroll down
MId.SRt  rmb   1          scroll right
MId.SLt  rmb   1          scroll left
MId.Chr  rmb   1          character was depressed
         org   20
MId.Tdy  rmb   1          Tandy menu
MId.Fil  rmb   1          Files Menu
MId.Edt  rmb   1          Edit Menu
MId.Sty  rmb   1          Styles menu
MId.Fnt  rmb   1          Font menu


******************************************************************************
******************************************************************************
**                                                                          **
** OS-9 Windowing system Global data definitions                            **
**                                                                          **
******************************************************************************
******************************************************************************
**                                                                          **
** System memory block 0 layout:                                            **
**                                                                          **
** $0000-$0001 : FHL/Isted WD 1002-05 - interface base address              **
** $0002       : FHL/Isted WD 1002-05 - boot device physical drive #        **
** $0008       : Bruce Isted Serial mouse - button counter & rx count       **
** $0009-$000B : Bruce Isted Serial mouse - RX buffer                       **
** $000C-$000D : Bruce Isted Serial mouse - Current X position              **
** $000E-$000F : Bruce Isted Serial mouse - Current Y position              **
** $0010-$001F : unused (User definable)                                    **
** $0020-$00FF : system direct page & some IRQ vectors                      **
** $0100-$011F : Task usage table                                           **
** $0120-$01FF : Virtual DAT tasks (pointed to by <D.TskIPt)                **
** $0200-$02FF : memory block usage map ($80=Not RAM,$01=in use,$02=module) **
** $0300-$03FF : system's system call dispatch table                        **
** $0400-$04FF : user's sysem call dispatch table                           **
** $0500-$05FF : process descriptor pointer table                           **
** $0600-$07FF : System task (Task 0, ID 1) process descriptor              **
** $0800-$08FF : System's stack space (initial ptr is $0900)                **
** $0900-$09FF : SMAP table ($01=in used, $80=NOT RAM)                      **
** $0A00-$0FFF : module directory DAT Images (8 bytes each)                 **
** $1000-$10FF : System Global memory (pointed to by D.CCMem)               **
** $1100-$11FF : GRFDRV global memory (DP=$11 in GRFDRV)                    **
** $1200-$1247 : shared buffer between Grf/WindInt & GRFDRV (GP buffers)    **
** $1248-$127F : ????                                                       **
** $1280-$1A7F : the window tables (32 of $40 bytes each)                   **
** $1A80-$1C7F : the screen tables (16 of $20 bytes each)                   **
** $1C80-$2000 : the CC3 global mem stack (for windowing)                   **
**                                                                          **
******************************************************************************
******************************************************************************

* User settable values for CC3IO/TC9IO/GrfInt/WindInt & GrfDrv
MaxLines equ   25         Max. Y coord text value
Meg      set   false      "true" if 1 or 2 meg machine

COMP     equ   0          composite monitor
RGB      equ   1          RGB Analog monitor 
MONO     equ   2          monochrome monitor

Monitor  set   RGB

* Global definitions
KeyMse   equ   %00000001  keyboard mouse enabled
NumLck   equ   %00000010  Numlock enabled (TC-9 use only)
CapsLck  equ   %00000100  Capslock enabled
MaxRows  equ   640        maximum X co-ordinate allowed on mouse
         IFEQ  MaxLines-25
MaxLine  equ   198        maximum Y co-ordinate allowed on mouse
         ELSE  
MaxLine  equ   191        maximum Y co-ordinate allowed on mouse
         ENDC  

*****************************************************************************
* Static memory area for each window (CC3IO/TC9IO)
* Should set up a write buffer (using parm area?) between SCF, CC3IO & Grfdrv
* so we can 'burst mode' text output (copy up to 48 chars to Grfdrv's parm
* area, and have grfdrv loop through & write all 48 chars to screen in 1 loop
* May have to have smaller limit for text to gfx screens, as it will run much
* slower, unless GrfDrv is made Partially/Fully Re-Entrant
*
* STRONG CAUTION:  scfdefs MUST be included first before this file if
* V.SCF is to be resolved properly in pass 1!!
         org   V.SCF

WinType  rmb   1          window type (0=Windint/GrfInt,2=VDGInt)      $1D
InfVld   rmb   1          Rest of info here valid? (0=NO, >0 = YES)    $1E
DevPar   rmb   2          high bit=window device                       $1F
ULCase   rmb   1          special key flags (Capslck & keyboard mouse) $21
KySnsFlg rmb   1          flag for key sense setstat                   $22
ScrChg   rmb   1          screen change flag                           $23
SS.SigID rmb   1          data ready process ID                        $24
SS.SigSg rmb   1          data ready signal code                       $25
MS.SigID rmb   1          mouse signal process ID                      $26
MS.SigSg rmb   1          mouse signal signal code                     $27
MS.Smpl  rmb   1          mouse sample rate                            $28
MS.Time  rmb   1          mouse timeout value                          $29
MS.Side  rmb   1          MSB of mouse auto-follow flag                $2A
PrtSide  rmb   1          auto follow mouse flag                       $2B
ParmCnt  rmb   1          parameter count                              $2C
ParmVct  rmb   2          parameter vector                             $2D
PrmStrt  rmb   2          pointer to params start                      $2F
NxtPrm   rmb   2          pointer to next param storage                $31
EndPtr   rmb   1          last character read offset                   $33
InpPtr   rmb   1          next character read offset                   $34
WinNum   rmb   1          window table entry #                         $35
DWNum    rmb   1          dwnum from descriptor                        $36
CallCde  rmb   1          internal comod call code #                   $37
CC3Parm  rmb   128-.      global parameter area
ReadBuf  rmb   256-.      read input buffer (keyboard)
CC3DSiz  equ   .

*****************************************************************************
* GrfInt/WindInt global memory area
* This area sits in system block 0 from $1000 to $10ff
WGlobal  equ   $1000      useful value (points to address starting below)
         org   0
G.CurTik rmb   1          Constant - # Clock ticks/cursor updates (2)
G.CntTik rmb   1          Current tick count for cursor updates
G.GfBusy rmb   1          Grfdrv is busy flag (1=busy)
g0003    rmb   2          NEW: UNUSED
g0005    rmb   2          ???
G.GrfStk rmb   2          grfdrv stack pointer ($07)
G.MonTyp rmb   1          monitor type
g000A    equ   .          Old label for compatibility
G.CrDvFl rmb   1          Are we current device flag (only set when all
*                           Parms have been moved to Dev Mem)
*                           0=We are not on our device
*                           1=We are the current device
*                           (Used by comod (GRF/WIND/VDGInt) to determine
*                            whether or not to update GIME regs themselves
*                            If not current device, they don't.)
g000B    rmb   1          current device's V.TYPE
G.CurDvM rmb   2          current device memory pointer for co-module use
G.WIBusy rmb   1          WindInt is busy flag (1=busy)
G.AlPckt rmb   6          F$Alarm time packet
G.AlPID  rmb   1          F$Alarm proc ID ($15)
G.AlSig  rmb   1          F$Alarm signal code ($16)
G.BelVec rmb   2          BELL routine vector
G.DefPal rmb   2          pointer to default palette data in global mem
G.TnCnt  rmb   1          SS.Tone duration counter
G.BelTnF rmb   1          BELL tone flag
g001D    rmb   3
G.CurDev rmb   2          current device's static memory pointer ($20)
G.PrWMPt rmb   2          previous window static mem pointer $(22)
G.BCFFlg rmb   1          bit coded co-module found flags ($24)
*                           00000010 : VDGInt found
*                           10000000 : GrfDrv found
g0025     rmb   1
G.KTblLC  rmb   1          Key table entry# last checked (1-3)
*         IFEQ  TC9-true
*CurLght  rmb   1          current keyboard light settings
*         ELSE  
G.LastCh  rmb   1          last keyboard character (ASCII value)
*         ENDC  
G.LKeyCd  rmb   1          last keyboard code
G.KyRept rmb   1          key repeat counter
* A secondary 3 key table (same format as g002D below)
G.2Key1  rmb   1		$2A
G.2Key2  rmb   1		$2B
G.2Key3  rmb   1
* Up to 3 keys can be registerd at once, and they are stored here. If more
* than 3 are hit, the last key is overwritten with the very last key down that
* was checked. Format for all three is the same as the PIA column/row byte @
* KeyFlag below.
G.Key1   rmb   1          Key 1 being held down (Row/Column #)
G.Key2   rmb   1          Key 2 being held down (Row/Column #)
G.Key3   rmb   1          Key 3 being held down (Row/Column #)
G.ShftDn rmb   1          SHIFT key down flag (COM'd) ($30)
G.CntlDn rmb   1          CTRL key down flag (0=NO)
G.KeyFlg rmb   1          Keyboard PIA bit #'s for columns/rows
*                           %00000111-Column # (Output, 0-7)
*                           %00111000-Row # (Input, 0-6)
G.AltDwn rmb   1          ALT key down flag (0=NO)
G.KySns  rmb   1          key sense byte
G.KySame rmb   1          same key flag
G.CapLok rmb   1          CapsLock/SysRq key down flag
         rmb   1
g0038    rmb   1          grfdrv initialized flag
         rmb   2
G.MSmpRt rmb   1          Current mouse sample # (# ticks till next read)
G.Mouse  rmb   Pt.Siz     mouse packet ($3C)
g005C    rmb   2          Temp for relative mouse X coord calculation
g005E    rmb   2          Temp for relative mouse Y coord calculation
G.MSmpRV rmb   1          Mouse sample reset value (# ticks till next read)
G.KyDly  rmb   1          initial key repeat delay constant
G.KySpd  rmb   1          secondary key repeat delay constant
*         IFEQ  TC9-true
*KeyParm  rmb   1          keyboard command parameter byte
*         ELSE  
G.KyMse  rmb   1          keyboard mouse flag
*         ENDC  
G.Clear  rmb   1          "one-shot" CapsLock/SysRq key flag
G.KyButt rmb   1          keyboard F1 and F2 "fire" button info
G.AutoMs rmb   1          Auto-follow mouse flag for current device (0=NO)
G.MseMv  rmb   1          mouse moved flag
G.CoTble rmb   6          co-module table
G.GrfEnt rmb   2          GRFDRV Entry address ($6E)
g0070    rmb   1          # bytes to move in 1 block (1-72)
G.WUseTb rmb   4          windows in use bit table (0=unused, 32 windows) ($71)
G.GfxTbl rmb   2          Pointer to GFX tables ($75)
G.WrkWTb rmb   $40        Work window table. WindInt only ($77)
g00B7    rmb   2          Current Device static mem ptr for WindInt
g00B9    rmb   2          Current window table ptr for WindInt
g00BB    rmb   2          Pointer to work window table (g0077+$10)
g00BD    rmb   1          Current screen type for work window table
g00BE    rmb   1          Topmost overlay window # when check for title bars
g00BF    rmb   1          Flag for keypress while processing menu select
g00C0    rmb   2          Ptr to current path descriptor
G.WindBk rmb   2          shift-clear routine vector
G.MsInit rmb   2          set mouse routine vector
G.MsSig  rmb   1          mouse signal flag
G.DefPls rmb   16         Default palettes (2 repeats of 8 is default) ($C7)
g00D7    rmb   41

*****************************************************************************
* GrfDrv global memory data definitions
* This area sits in system block 0 from $1100 to $119E
GrfMem   equ   $1100      useful label used to point to mem starting below
         org   0
gr0000   rmb   1          Pixel mask for 1st byte of GP line
gr0001   rmb   1          Pixel mask for last byte of a GP line
gr0002   rmb   2          Ptr to table of bit masks for colors
gr0004   rmb   1          # of bytes wide GP buffer is (including partials)
gr0005   rmb   1          # pixels per byte in GP Buffer
gr0006   rmb   1          # of pixels used in 1st byte of GP buffer line
gr0007   rmb   1          # of pixels used in last byte of GP buffer line
gr0008   rmb   1          Bit mask that is common to both screen & GP buffer
gr0009   rmb   1          # bytes for width of overlay window
gr000A   rmb   1          # bytes to offset to get to next line after
*                             overlay width has been copied
gr000B   rmb   1
gr000C   rmb   2          Cursor address for proportional spacing?
gr000E   rmb   1
gr000F   rmb   1          Left-based bit mask for proportional spacing?
gr0010   rmb   2          Vector for text to gfx screen (either prop. or normal)
gr0012   rmb   6
gr0018   rmb   2          Working Center X coord for Circle/Ellipse
gr001A   rmb   2          Working Center Y coord for Circle/Ellipse
gr001C   rmb   2          Some variable for Circle/Ellipse (initially 0)
gr001E   rmb   2          Working Y radius value for Circle/Ellipse
gr0020   rmb   2          Arc 'clip line' X01
gr0022   rmb   2          Arc 'clip line' Y01
gr0024   rmb   2          Arc 'clip line' X02
gr0026   rmb   2          Arc 'clip line' Y02
gr0028   rmb   1          full-byte background color to FFILL on mask
gr0029   rmb   1          pixels per byte: set up by FFILL
gr002A   rmb   1          Flag for FFill: 1=no error, 0=Stack overflow error
gr002B   rmb   1          current Y-direction to travel in FFILL
gr002C   rmb   2
gr002E   rmb   2          current window table entry
gr0030   rmb   2          current screen table ptr
gr0032   rmb   1          Last block # we used for buffers
gr0033   rmb   2          Last offset we used for buffers
gr0035   rmb   1          group
gr0036   rmb   2          offset
gr0038   rmb   1          group returned (new)
gr0039   rmb   1          0=Text cursor inverted off, >0 is inverted on
gr003A   rmb   1          0=Graphics cursor XOR'd off,>0 is XOR'd on scrn
gr003B   rmb   2          end of vars ptr?
gr003D   rmb   2          Last X coordinate Graphics cursor was ON at
gr003F   rmb   2          Last Y coordinate Graphics cursor was ON at
gr0041   rmb   2          Screen address for start of current gfx cursor
gr0043   rmb   1          Pixel mask for start of gfx cursor
gr0044   rmb   1          Block # Graphics cursor is in
gr0045   rmb   2          Offset in block Graphics cursor is in
gr0047   rmb   2          'Working' X coordinate
gr0049   rmb   2          'Working' Y coordinate
gr004B   rmb   2          current X
gr004D   rmb   2          current Y
gr004F   rmb   2          X Size (in bytes)
gr0051   rmb   2          Y Size (in bytes)
gr0053   rmb   2          Horizontal radius (circle/ellipse/arc)
gr0055   rmb   2          Vertical radius (circle/ellipse/arc)
gr0057   rmb   1          group
gr0058   rmb   1          buffer #
gr0059   rmb   1          save switch for overlay
gr005A   rmb   1          PRN
gr005B   rmb   2          X coordinate of Graphics cursor
gr005D   rmb   2          Y coordinate of Graphics cursor
gr005F   rmb   1          ATD: new video mode for 24/25/28-line windows
Gr.STYMk rmb   1          STY marker
gr0061   rmb   1          foreground RGB data
gr0062   rmb   1          background RGB data
gr0063   rmb   1          bytes/row (on current screen...not window)
gr0064   rmb   2          PSet vector
gr0066   rmb   2          pset offset
gr0068   rmb   2          LSet vector
gr006A   rmb   2          max X co-ordinate
gr006C   rmb   2          max Y co-ordinate
gr006E   rmb   2          X pixel count
gr0070   rmb   2          Y pixel count
gr0072   rmb   2          Screen address of pixel we are doing
gr0074   rmb   1          Pixel mask for pixel we are doing
gr0075   rmb   2          ??? Pixel mask for last byte of GP buffer?
gr0077   rmb   2          Vector for right direction FFill
gr0079   rmb   1          bit mask for 1st pixel in byte for right dir. FFill
gr007A   rmb   2          Vector for left direction FFill
gr007C   rmb   1          bit mask for last pixel in byte for left dir. FFill
gr007D   rmb   1          buffer block #
gr007E   rmb   2          buffer offset #
gr0080   rmb   2          Buffer length (in bytes)
gr0082   rmb   3          3 byte extended screen address
gr0085   rmb   2          temp
gr0087   rmb   16         grfdrv (sysmap 1) DAT image
gr0097   rmb   1          temp
gr0098   rmb   1          temp
* In ARC, 97-98 is the width of the clip line in pixels (after scaling)
gr0099   rmb   2          temp
* In ARC, 99-9A is the height of the clip line in pixels (after scaling)
gr009B   rmb   1          counter temp
gr009C   rmb   1
gr009D   rmb   2          offset to buffer in block
gr009F   rmb   1
gr00A0   rmb   1          # lines left to do of GP buffer onto screen
gr00A1   rmb   2          vector routine for (changes lots)
* In ARC A1-A2 is the vector to the proper clipping routine
gr00A3   rmb   2          Vector for shifting GP buffers
gr00A5   rmb   2          Vector for shifting GP buffers (can dupe A1)
gr00A7   rmb   2
gr00A9   rmb   2          NEW: Window tbl ptr for last window GRFDRV used
grBigFnt rmb    2           Flag for 224 char font/gfx mode on (0=No) V2.00a
gr00AD   rmb    2           FFill:orig. start X coord|Circ/Ell saved start X
gr00AF   rmb    2           FFill:orig. start Y coord|Circ/Ell saved end X
gr00B1   rmb    1           Flag in FFill: 1=1st time through, 0=not 1st time
gr00B2   rmb    1           Filled (circle,ellipse) flag 0=Not filled
gr00B3   rmb    256-.       ??? UNUSED
* GPLoad buffer - $1200 in system block 0
GPBuf    rmb   72         common move buffer for gpload/get/put
gb0000   equ   72         Size of get/put buffer ($48)

*****************************************************************************
* Window table entry structure
* These tables sit in system block 0 and there is 1 for every window init'd
* including any overlay windows.
MaxWind  equ   32         maximum allowable window tables
WinBase  equ   $1290      base address to start of window tables
         org   -$10
Wt.STbl  rmb   2          Screen table pointer ($FFFF=Not used)       -$10
Wt.BLnk  rmb   1          overlay window parent entry # ($FF=base)    -$0E
Wt.LStrt rmb   2          screen logical start address                -$0D
Wt.CPX   rmb   1          current X coord. start                      -$0B
Wt.CPY   rmb   1          current Y coord. start                      -$0A
Wt.SZX   rmb   1          current X size (CWArea)                     -$09
Wt.SZY   rmb   1          current Y size (CWArea)                     -$08
Wt.SXFct rmb   1          X scaling factor                            -$07
Wt.SYFct rmb   1          Y scaling factor (0=no scaling)             -$06
Wt.Cur   rmb   2          cursor physical address on screen           -$05
Wt.FMsk  rmb   1          font bit mask (based from left)             -$03
Wt.CurX  rmb   2          X coord of cursor                           -$02
Wt.CurY  rmb   2          Y Coord of cursor                            $00
Wt.XBCnt rmb   1          width of window (in bytes)                   $02
Wt.CWTmp rmb   1          bytes wide each text chr (1,2,4)             $03
Wt.BRow  rmb   2          bytes/text row (8x width in gfx)             $04
Wt.Fore  rmb   1          foreground palette #                         $06
Wt.Back  rmb   1          background palette #                         $07
Wt.Attr  rmb   1          default attributes (FUTTTBBB)                $08
Wt.BSW   rmb   1          character BSW switches                       $09
Wt.LSet  rmb   1          LSet type                                    $0A
Wt.FBlk  rmb   1          Font memory block #                          $0B
Wt.FOff  rmb   2          Font offset in block                         $0C
Wt.PBlk  rmb   1          PSet memory block #                          $0E
Wt.POff  rmb   2          PSet offset in block                         $0F
Wt.OBlk  rmb   1          Overlay memory block #                       $11
Wt.OOff  rmb   2          Overlay offset in block                      $12
Wt.LVec  rmb   2          LSet vector                                  $14
Wt.PVec  rmb   2          PSet vector                                  $16
Wt.GBlk  rmb   1          GCursor memory block #                       $18
Wt.GOff  rmb   2          GCursor offset in block                      $19
Wt.MaxX  rmb   2          Maximum X cord. (0-79,0-639)                 $1B
Wt.MaxY  rmb   2          Maximum Y cord. (0-24,0-191)                 $1D
Wt.BLen  rmb   2          bytes left in GPLoad block below             $1F
Wt.NBlk  rmb   1          memory block # for next GPLoad               $21
Wt.NOff  rmb   2          Offset in block for next GPLoad              $22
Wt.LStDf rmb   2          screen logical start default                 $24
* NOTE: The following default settings are what the window was initialized
*       with, and thus are the MAXIMUM start/size the window can handle
*       until it is restarted (DWEnd & DWSet)
*       They also appear to be used in WindInt to determine the coords &
*       sizes for control+content regions
Wt.DfCPX rmb   1          default X cord. start                        $26
Wt.DfCPY rmb   1          default Y cord. start                        $27
Wt.DfSZX rmb   1          default X size                               $28
Wt.DfSZY rmb   1          default Y size                               $29
Wt.Res   rmb   6          unused                                   $2A-$2F
Wt.Siz   equ   .+$10

*****************************************************************************
* Screen table entrys
* These tables sit in system block 0 base=$1A80

STblMax  equ   16         Maximum number of screen tables
STblBse  equ   $1A80      base address of screen tables
         org   0
St.Sty   rmb   1          Screen type                         $00
St.SBlk  rmb   1          Ram block start #                   $01
St.LStrt rmb   2          Screen logical start (for GIME)     $02
St.BRow  rmb   1          Bytes per row                       $04
St.Brdr  rmb   1          Border palette register #           $05
St.Fore  rmb   1          Foreground palette register #       $06
St.Back  rmb   1          Background palette register #       $07
St.ScSiz rmb   1          screen size: 24..28 lines           $08
St.Res   rmb   7          UNUSED???                           $09
* NOTE: SHOULD USE ONE OF THESE UNUSED BYTES TO KEEP THE # OF DEVICE WINDOW
* TABLES THAT ARE USING THIS SCREEN TABLE. DWSET & DWEND WOULD KEEP TRACK OF
* THESE, AND THE WINDINT TITLE BAR ROUTINE WOULD CHECK IT. IF IT IS ONLY 1,
* IT WON'T BOTHER CHANGING THE TITLE BAR WHEN SELECTING WINDOWS
St.Pals  rmb   16         Palette register contents           $10
St.Siz   equ   .

*****************************************************************************
* Graphics buffer tables
* They contain a 20 byte header (shown below), followed by the raw pixel
* data.
         org   0
Grf.Bck  rmb   1          back block link #                   $00
Grf.Off  rmb   2          back block header offset            $01
Grf.Grp  rmb   1          group #                             $03
Grf.Buff rmb   1          buffer #                            $04
Grf.BSz  rmb   2          buffer size (not including header)  $05
Grf.XSz  rmb   2          X size (in pixels)                  $07
Grf.YSz  rmb   2          Y size (in pixels/bytes)            $09
Grf.XBSz rmb   1          X size in bytes                     $0B
Grf.LfPx rmb   1          # pixels used in first byte of line $0C
Grf.RtPx rmb   1          # pixels used in last byte of line  $0D
Grf.STY  rmb   1          Screen type buffer intended for     $0E
Grf.NBlk rmb   1          number blocks used                  $0F
Grf.Pal  rmb   16         Copy of palette registers?          $10
Grf.Siz  equ   .          $20

*****************************************************************************
* GFX tables (1 for each window, 18 ($12) bytes each) pointed to by
* $1075-$0176
* GRFINT only uses gt0001-gt0004, the rest is exclusive to WINDINT
         org   0
Gt.WTyp  rmb   1          WindInt window type (Framed, Scroll Bar, etc.) $00
Gt.GXCur rmb   2          X coord of graphics cursor                     $01
Gt.GYCur rmb   2          Y coord of graphics cursor                     $03
Gt.DPtr  rmb   2          Ptr to WindInt window descriptor               $05
Gt.FClr  rmb   1          Foreground color                               $07
Gt.BClr  rmb   1          Background color                               $08
Gt.FMsk  rmb   1          Foreground mask                                $09
Gt.BMsk  rmb   1          Background mask                                $0A
Gt.GBlk  rmb   1          Block # of graphics cursor                     $0B
Gt.GOff  rmb   2          Offset into block of graphics cursor           $0C
Gt.Proc  rmb   1          Process # of window creator                    $0E
Gt.PBlk  rmb   1          Process descriptor block # of creator          $0F
Gt.Res   rmb   2          ??? RESERVED ???                               $10
GTabSz   equ   .

*****************************************************************************
* This table is located in the graphics table memory and is offset from
* graphics table pointer stored at $1075-$1076. This is used exclusively by
* WindInt.
* NOTE: USING UNUSED BYTES IN CC3 GLOBAL MEM, SET UP SEPARATE PTRS FOR EACH
*  OF THE BELOW SO WE CAN SPEED UP ACCESS BY NOT HAVING TO DO A LOAD/LEAx
*  COMBINATION EVERY TIME
         org   $0240
         rmb   WN.SIZ     copy of last accessed window descriptor
         rmb   MN.SIZ     copy of last accessed menu descriptor
         rmb   MI.SIZ     copy of last accessed item descriptor
         rmb   65         menu handling table (16 entrys of 4 bytes)

*****************************************************************************
* WindInt menu handling table entry definition
         org   0
MnuXNum  rmb   1          menu #
MnuXStrt rmb   1          X start text co-ordinate
MnuXEnd  rmb   1          X end text co-ordinate
         rmb   1          unused?
MnuHSiz  equ   .

*****************************************************************************
* Character binary switches
TChr     equ   %10000000  transparent characters
Under    equ   %01000000  underline characters
Bold     equ   %00100000  bold characters
Prop     equ   %00010000  proportional spacing of characters
Scale    equ   %00001000  automatic window scaling
Invers   equ   %00000100  inverse characters
NoCurs   equ   %00000010  no cursor display
Protect  equ   %00000001  device window protection

*****************************************************************************
* Screen types (high bit set=hardware text, else graphics) in GRFDRV
Current  equ   $ff        Current screen
*         equ   1          640x200x2
*         equ   2          320x200x4
*         equ   3          640x200x4
*         equ   4          320x200x16
*         equ   $85        80 column text
*         equ   $86        40 column text

*************************************
* Window default palette color codes
*
         org   0
White.   rmb   1
Blue.    rmb   1
Black.   rmb   1
Green.   rmb   1
Red.     rmb   1
Yellow.  rmb   1
Magenta. rmb   1
Cyan.    rmb   1

         ENDC
         ENDC

