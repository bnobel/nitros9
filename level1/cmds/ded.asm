             IFNE   1
L0000    fcb   $87,$CD,$17,$A2,$00,$1C,$11,$82   .M."....
L0008    fcb   $8F,$06,$65,$03,$16,$0C,$1F,$20   ..e.... 
L0010    fcb   $00,$1F,$21,$00,$04,$0B,$05,$21   ..!....!
L0018    fcb   $00,$05,$20,$00,$64,$45,$E4,$05   .. .dEd.
L0020    fcb   $43,$6F,$70,$79,$72,$69,$67,$68   Copyrigh
L0028    fcb   $74,$20,$31,$39,$38,$37,$20,$44   t 1987 D
L0030    fcb   $6F,$75,$67,$20,$44,$65,$4D,$61   oug DeMa
L0038    fcb   $72,$74,$69,$6E,$69,$73,$4C,$53   rtinisLS
L0040    fcb   $4E,$3D,$A4,$53,$45,$43,$54,$4F   N=$SECTO
L0048    fcb   $52,$20,$3D,$20,$A4,$20,$20,$20   R = $   
L0050    fcb   $20,$20,$20,$30,$20,$20,$31,$20      0  1 
L0058    fcb   $20,$32,$20,$20,$33,$20,$20,$34    2  3  4
L0060    fcb   $20,$20,$35,$20,$20,$36,$20,$20     5  6  
L0068    fcb   $37,$20,$20,$38,$20,$20,$39,$20   7  8  9 
L0070    fcb   $20,$41,$20,$20,$42,$20,$20,$43    A  B  C
L0078    fcb   $20,$20,$44,$20,$20,$45,$20,$20     D  E  
L0080    fcb   $46,$20,$20,$20,$20,$30,$20,$32   F    0 2
L0088    fcb   $20,$34,$20,$36,$20,$38,$20,$41    4 6 8 A
L0090    fcb   $20,$43,$20,$45,$20,$0D,$43,$4D    C E .CM
L0098    fcb   $44,$3A,$A0,$3C,$42,$52,$45,$41   D: <BREA
L00A0    fcb   $4B,$3E,$20,$74,$6F,$67,$67,$6C   K> toggl
L00A8    fcb   $65,$73,$20,$48,$45,$58,$2F,$41   es HEX/A
L00B0    fcb   $53,$43,$49,$49,$20,$65,$64,$69   SCII edi
L00B8    fcb   $74,$20,$6D,$6F,$64,$65,$73,$20   t modes 
L00C0    fcb   $20,$20,$20,$20,$3C,$45,$4E,$54       <ENT
L00C8    fcb   $45,$52,$3E,$20,$65,$78,$69,$74   ER> exit
L00D0    fcb   $73,$20,$65,$64,$69,$74,$20,$6D   s edit m
L00D8    fcb   $6F,$64,$E5,$5A,$61,$70,$A0,$62   odeZap b
L00E0    fcb   $79,$74,$65,$3A,$A0,$63,$68,$61   yte: cha
L00E8    fcb   $72,$3A,$A0,$41,$72,$65,$20,$79   r: Are y
L00F0    fcb   $6F,$75,$20,$73,$75,$72,$65,$3F   ou sure?
L00F8    fcb   $20,$28,$59,$2F,$4E,$29,$A0,$57    (Y/N) W
L0100    fcb   $72,$69,$74,$69,$6E,$67,$20,$73   riting s
L0108    fcb   $65,$63,$74,$6F,$72,$2E,$2E,$AE   ector...
L0110    fcb   $4F,$55,$54,$46,$49,$4C,$45,$3A   OUTFILE:
L0118    fcb   $A0,$56,$65,$72,$69,$66,$79,$69    Verifyi
L0120    fcb   $6E,$67,$2E,$2E,$AE,$56,$65,$72   ng...Ver
L0128    fcb   $69,$66,$79,$20,$61,$62,$6F,$72   ify abor
L0130    fcb   $74,$65,$64,$2E,$2E,$AE,$73,$68   ted...sh
L0138    fcb   $65,$6C,$EC,$4C,$69,$6E,$6B,$20   ellLink 
L0140    fcb   $74,$6F,$20,$77,$68,$69,$63,$68   to which
L0148    fcb   $20,$6D,$6F,$64,$75,$6C,$65,$3F    module?
L0150    fcb   $A0,$4F,$66,$66,$20,$20,$4C,$65    Off  Le
L0158    fcb   $6E,$20,$20,$4E,$61,$6D,$65,$0A   n  Name.
L0160    fcb   $2D,$2D,$2D,$2D,$20,$2D,$2D,$2D   ---- ---
L0168    fcb   $2D,$20,$2D,$2D,$2D,$2D,$0D,$4D   - ----.M
L0170    fcb   $4F,$44,$55,$4C,$45,$3A,$20,$A0   ODULE:  
L0178    fcb   $4F,$46,$46,$53,$45,$54,$3A,$20   OFFSET: 
L0180    fcb   $A4,$1F,$24,$2D,$20,$45,$78,$70   $.$- Exp
L0188    fcb   $65,$72,$74,$20,$4D,$6F,$64,$65   ert Mode
L0190    fcb   $20,$2D,$1F,$A5,$46,$69,$6E,$64    -.%Find
L0198    fcb   $20,$62,$79,$74,$65,$20,$73,$74    byte st
L01A0    fcb   $72,$69,$6E,$67,$20,$A4,$46,$69   ring $Fi
L01A8    fcb   $6E,$64,$20,$63,$68,$61,$72,$20   nd char 
L01B0    fcb   $73,$74,$72,$69,$6E,$67,$3A,$A0   string: 
L01B8    fcb   $53,$65,$61,$72,$63,$68,$69,$6E   Searchin
L01C0    fcb   $67,$2E,$2E,$AE,$43,$75,$72,$72   g...Curr
L01C8    fcb   $65,$6E,$74,$20,$46,$69,$6C,$65   ent File
L01D0    fcb   $20,$4C,$65,$6E,$67,$74,$68,$20    Length 
L01D8    fcb   $A4,$4E,$65,$77,$20,$4C,$65,$6E   $New Len
L01E0    fcb   $67,$74,$68,$3F,$20,$A4,$2A,$2A   gth? $**
L01E8    fcb   $20,$52,$45,$53,$54,$41,$52,$54    RESTART
L01F0    fcb   $2C,$20,$45,$6E,$74,$65,$72,$20   , Enter 
L01F8    fcb   $70,$61,$74,$68,$6E,$61,$6D,$65   pathname
L0200    fcb   $3A,$A0,$42,$41,$4D,$3A,$20,$46   : BAM: F
L0208    fcb   $72,$6F,$6D,$20,$53,$65,$63,$74   rom Sect
L0210    fcb   $6F,$72,$3A,$24,$20,$20,$20,$20   or:$    
L0218    fcb   $20,$20,$20,$74,$6F,$20,$24,$20      to $ 
L0220    fcb   $20,$20,$20,$20,$20,$A0,$42,$69         Bi
L0228    fcb   $74,$73,$BA,$07,$53,$65,$63,$74   ts:.Sect
L0230    fcb   $6F,$72,$20,$53,$74,$61,$63,$6B   or Stack
L0238    fcb   $20,$46,$75,$6C,$6C,$A0,$20,$20    Full   
L0240    fcb   $20,$55,$70,$2F,$44,$6F,$77,$6E    Up/Down
L0248    fcb   $20,$41,$72,$72,$6F,$77,$73,$20    Arrows 
L0250    fcb   $20,$52,$65,$61,$64,$20,$26,$20    Read & 
L0258    fcb   $64,$69,$73,$70,$6C,$61,$79,$20   display 
L0260    fcb   $4E,$65,$78,$74,$2F,$50,$72,$65   Next/Pre
L0268    fcb   $76,$69,$6F,$75,$73,$20,$73,$65   vious se
L0270    fcb   $63,$74,$6F,$72,$0A,$20,$3C,$43   ctor. <C
L0278    fcb   $52,$3E,$20,$43,$6C,$65,$61,$6E   R> Clean
L0280    fcb   $20,$75,$70,$20,$74,$68,$65,$20    up the 
L0288    fcb   $73,$63,$72,$65,$65,$6E,$20,$64   screen d
L0290    fcb   $69,$73,$70,$6C,$61,$79,$0A,$20   isplay. 
L0298    fcb   $20,$20,$2A,$20,$20,$52,$65,$73     *  Res
L02A0    fcb   $74,$61,$72,$74,$0A,$20,$20,$20   tart.   
L02A8    fcb   $24,$20,$20,$46,$6F,$72,$6B,$20   $  Fork 
L02B0    fcb   $61,$20,$53,$48,$45,$4C,$4C,$20   a SHELL 
L02B8    fcb   $28,$43,$74,$72,$6C,$2D,$42,$52   (Ctrl-BR
L02C0    fcb   $45,$41,$4B,$20,$74,$6F,$20,$72   EAK to r
L02C8    fcb   $65,$74,$75,$72,$6E,$29,$0A,$20   eturn). 
L02D0    fcb   $20,$20,$41,$20,$20,$41,$70,$70     A  App
L02D8    fcb   $65,$6E,$64,$20,$64,$69,$73,$70   end disp
L02E0    fcb   $6C,$61,$79,$65,$64,$20,$73,$65   layed se
L02E8    fcb   $63,$74,$6F,$72,$20,$74,$6F,$20   ctor to 
L02F0    fcb   $6F,$75,$74,$70,$75,$74,$20,$66   output f
L02F8    fcb   $69,$6C,$65,$0A,$20,$20,$20,$43   ile.   C
L0300    fcb   $20,$20,$43,$6C,$6F,$73,$65,$20     Close 
L0308    fcb   $6F,$75,$74,$70,$75,$74,$20,$66   output f
L0310    fcb   $69,$6C,$65,$0A,$20,$20,$20,$44   ile.   D
L0318    fcb   $20,$20,$44,$69,$64,$64,$6C,$65     Diddle
L0320    fcb   $20,$28,$61,$64,$6A,$75,$73,$74    (adjust
L0328    fcb   $29,$20,$66,$69,$6C,$65,$20,$6C   ) file l
L0330    fcb   $65,$6E,$67,$74,$68,$0A,$20,$20   ength.  
L0338    fcb   $20,$45,$20,$20,$45,$64,$69,$74    E  Edit
L0340    fcb   $20,$74,$68,$65,$20,$64,$69,$73    the dis
L0348    fcb   $70,$6C,$61,$79,$65,$64,$20,$73   played s
L0350    fcb   $65,$63,$74,$6F,$72,$0A,$20,$20   ector.  
L0358    fcb   $20,$46,$20,$20,$46,$69,$6E,$64    F  Find
L0360    fcb   $20,$61,$20,$62,$79,$74,$65,$20    a byte 
L0368    fcb   $6F,$72,$20,$74,$65,$78,$74,$20   or text 
L0370    fcb   $73,$74,$72,$69,$6E,$67,$20,$28   string (
L0378    fcb   $42,$52,$45,$41,$4B,$20,$61,$62   BREAK ab
L0380    fcb   $6F,$72,$74,$73,$29,$0A,$20,$20   orts).  
L0388    fcb   $20,$48,$20,$20,$48,$65,$6C,$70    H  Help
L0390    fcb   $20,$73,$63,$72,$65,$65,$6E,$20    screen 
L0398    fcb   $28,$61,$6C,$73,$6F,$20,$75,$73   (also us
L03A0    fcb   $65,$20,$27,$3F,$27,$29,$0A,$20   e '?'). 
L03A8    fcb   $20,$20,$4C,$20,$20,$4C,$69,$6E     L  Lin
L03B0    fcb   $6B,$20,$74,$6F,$20,$61,$20,$6D   k to a m
L03B8    fcb   $6F,$64,$75,$6C,$65,$20,$2D,$20   odule - 
L03C0    fcb   $4C,$69,$73,$74,$20,$61,$6C,$6C   List all
L03C8    fcb   $20,$6D,$6F,$64,$75,$6C,$65,$73    modules
L03D0    fcb   $0A,$20,$20,$20,$4E,$20,$20,$4E   .   N  N
L03D8    fcb   $65,$78,$74,$20,$6F,$63,$63,$75   ext occu
L03E0    fcb   $72,$72,$65,$6E,$63,$65,$20,$6F   rrence o
L03E8    fcb   $66,$20,$62,$79,$74,$65,$28,$73   f byte(s
L03F0    fcb   $29,$20,$6F,$72,$20,$73,$74,$72   ) or str
L03F8    fcb   $69,$6E,$67,$20,$28,$46,$69,$6E   ing (Fin
L0400    fcb   $64,$29,$0A,$20,$20,$20,$4F,$20   d).   O 
L0408    fcb   $20,$4F,$70,$65,$6E,$20,$61,$20    Open a 
L0410    fcb   $66,$69,$6C,$65,$20,$66,$6F,$72   file for
L0418    fcb   $20,$6F,$75,$74,$70,$75,$74,$20    output 
L0420    fcb   $28,$75,$73,$65,$20,$77,$69,$74   (use wit
L0428    fcb   $68,$20,$41,$70,$70,$65,$6E,$64   h Append
L0430    fcb   $29,$0A,$20,$20,$20,$50,$20,$20   ).   P  
L0438    fcb   $50,$75,$73,$68,$20,$63,$75,$72   Push cur
L0440    fcb   $72,$65,$6E,$74,$20,$73,$65,$63   rent sec
L0448    fcb   $74,$6F,$72,$20,$6F,$6E,$74,$6F   tor onto
L0450    fcb   $20,$73,$74,$61,$63,$6B,$0A,$20    stack. 
L0458    fcb   $20,$20,$51,$20,$20,$51,$75,$69     Q  Qui
L0460    fcb   $74,$20,$64,$45,$64,$20,$2D,$20   t dEd - 
L0468    fcb   $45,$78,$69,$74,$20,$74,$6F,$20   Exit to 
L0470    fcb   $4F,$53,$39,$0A,$20,$20,$20,$52   OS9.   R
L0478    fcb   $20,$20,$52,$65,$6D,$6F,$76,$65     Remove
L0480    fcb   $20,$61,$6E,$64,$20,$64,$69,$73    and dis
L0488    fcb   $70,$6C,$61,$79,$20,$61,$20,$73   play a s
L0490    fcb   $65,$63,$74,$6F,$72,$20,$66,$72   ector fr
L0498    fcb   $6F,$6D,$20,$73,$74,$61,$63,$6B   om stack
L04A0    fcb   $0A,$20,$20,$20,$53,$20,$20,$53   .   S  S
L04A8    fcb   $6B,$69,$70,$20,$74,$6F,$20,$67   kip to g
L04B0    fcb   $69,$76,$65,$6E,$20,$73,$65,$63   iven sec
L04B8    fcb   $74,$6F,$72,$20,$28,$73,$65,$63   tor (sec
L04C0    fcb   $74,$6F,$72,$20,$23,$20,$69,$6E   tor # in
L04C8    fcb   $20,$68,$65,$78,$29,$0A,$20,$20    hex).  
L04D0    fcb   $20,$55,$20,$20,$55,$6E,$6C,$69    U  Unli
L04D8    fcb   $6E,$6B,$20,$66,$72,$6F,$6D,$20   nk from 
L04E0    fcb   $6D,$6F,$64,$75,$6C,$65,$0A,$20   module. 
L04E8    fcb   $20,$20,$56,$20,$20,$56,$65,$72     V  Ver
L04F0    fcb   $69,$66,$79,$20,$61,$6C,$6C,$20   ify all 
L04F8    fcb   $6D,$6F,$64,$75,$6C,$65,$73,$20   modules 
L0500    fcb   $69,$6E,$20,$66,$69,$6C,$65,$0A   in file.
L0508    fcb   $20,$20,$20,$57,$20,$20,$57,$72      W  Wr
L0510    fcb   $69,$74,$65,$20,$74,$68,$65,$20   ite the 
L0518    fcb   $73,$65,$63,$74,$6F,$72,$20,$62   sector b
L0520    fcb   $61,$63,$6B,$20,$74,$6F,$20,$74   ack to t
L0528    fcb   $68,$65,$20,$64,$69,$73,$6B,$0A   he disk.
L0530    fcb   $20,$20,$20,$58,$20,$20,$65,$58      X  eX
L0538    fcb   $70,$65,$72,$74,$20,$6D,$6F,$64   pert mod
L0540    fcb   $65,$20,$74,$6F,$67,$67,$6C,$65   e toggle
L0548    fcb   $20,$6F,$6E,$2F,$6F,$66,$66,$0A    on/off.
L0550    fcb   $20,$20,$20,$5A,$20,$20,$5A,$61      Z  Za
L0558    fcb   $70,$20,$28,$66,$69,$6C,$6C,$20   p (fill 
L0560    fcb   $69,$6E,$29,$20,$74,$68,$65,$20   in) the 
L0568    fcb   $73,$65,$63,$74,$6F,$72,$20,$64   sector d
L0570    fcb   $69,$73,$70,$6C,$61,$79,$65,$64   isplayed
L0578    fcb   $0A,$0A,$20,$20,$20,$20,$20,$20   ..      
L0580    fcb   $28,$50,$72,$65,$73,$73,$20,$61   (Press a
L0588    fcb   $6E,$79,$20,$6B,$65,$79,$20,$74   ny key t
L0590    fcb   $6F,$20,$72,$65,$74,$75,$72,$6E   o return
L0598    fcb   $20,$74,$6F,$20,$63,$6F,$6D,$6D    to comm
L05A0    fcb   $61,$6E,$64,$20,$70,$72,$6F,$6D   and prom
L05A8    fcb   $70,$74,$29,$3A,$55,$73,$65,$3A   pt):Use:
L05B0    fcb   $20,$20,$64,$45,$64,$20,$3C,$70     dEd <p
L05B8    fcb   $61,$74,$68,$6C,$69,$73,$74,$3E   athlist>
L05C0    fcb   $0D,$98,$96,$80,$0F,$42,$40,$01   .....B@.
L05C8    fcb   $86,$A0,$00,$27,$10,$00,$03,$E8   . .'...h
L05D0    fcb   $00,$00,$64,$00,$00,$0A,$00,$00   ..d.....
L05D8    fcb   $01,$0C,$0A,$40,$0A,$0A,$4E,$2A   ...@..N*
L05E0    fcb   $06,$27,$24,$10,$BD,$0D,$10,$EF   .'$.=..o
L05E8    fcb   $73,$0A,$67,$7A,$0B,$23,$77,$0B   s.gz.#w.
L05F0    fcb   $D4,$6F,$0C,$26,$61,$0C,$AD,$63   To.&a.-c
L05F8    fcb   $0C,$97,$65,$0D,$37,$71,$0D,$22   ..e.7q."
L0600    fcb   $76,$11,$16,$6C,$12,$23,$75,$13   v..l.#u.
L0608    fcb   $CA,$78,$13,$EB,$68,$14,$13,$3F   Jx.kh..?
L0610    fcb   $14,$13,$66,$14,$2B,$6E,$15,$F9   ..f.+n.y
L0618    fcb   $64,$16,$12,$70,$16,$A9,$72,$16   d..p.)r.
L0620    fcb   $E2,$00,$E7,$C9,$00,$8B,$3B,$10   b.gI..;.
L0628    fcb   $DE,$1D,$DE,$1B,$03,$1A,$17,$0A   ^.^.....
L0630    fcb   $C4,$17,$01,$5B,$30,$8D,$FB,$AE   D..[0...
L0638    fcb   $17,$01,$1E,$17,$01,$72,$30,$C9   .....r0I
L0640    fcb   $01,$D6,$9F,$D6,$10,$8E,$00,$50   .V.V...P
L0648    fcb   $4F,$10,$3F,$8B,$10,$25,$06,$66   O.?..%.f
L0650    fcb   $10,$8C,$00,$01,$26,$08,$0F,$1A   ....&...
L0658    fcb   $17,$0A,$9A,$16,$00,$AD,$96,$00   .....-..
L0660    fcb   $10,$3F,$8F,$20,$0D,$9F,$D6,$30   .?. ..V0
L0668    fcb   $8D,$FF,$B7,$10,$3F,$09,$10,$25   ..7.?..%
L0670    fcb   $06,$44,$4F,$C6,$D6,$30,$C4,$A7   .DOFV0D'
L0678    fcb   $80,$5A,$26,$FB,$DF,$1B,$10,$DF   .Z&._.._
L0680    fcb   $1D,$CC,$00,$02,$DD,$0A,$32,$E8   .L..].2h
L0688    fcb   $E0,$30,$E4,$4F,$5F,$10,$3F,$8D   `0dO_.?.
L0690    fcb   $10,$25,$06,$22,$A6,$04,$97,$19   .%."&...
L0698    fcb   $32,$E8,$20,$9E,$D6,$34,$10,$0F   2h .V4..
L06A0    fcb   $8C,$A6,$80,$81,$0D,$27,$06,$81   .&...'..
L06A8    fcb   $40,$26,$F6,$03,$8C,$35,$10,$86   @&v..5..
L06B0    fcb   $03,$10,$3F,$84,$24,$11,$C1,$D6   ..?.$.AV
L06B8    fcb   $10,$26,$06,$78,$9E,$D6,$86,$83   .&.x.V..
L06C0    fcb   $10,$3F,$84,$10,$25,$06,$6D,$97   .?..%.m.
L06C8    fcb   $00,$C6,$02,$10,$3F,$8D,$9F,$49   .F..?..I
L06D0    fcb   $DF,$4B,$DE,$1B,$0F,$1A,$17,$0A   _K^.....
L06D8    fcb   $1C,$17,$00,$DE,$0D,$8C,$27,$15   ...^..'.
L06E0    fcb   $17,$00,$E1,$9E,$12,$EC,$04,$DD   ..a..l.]
L06E8    fcb   $8D,$1F,$01,$CC,$01,$00,$17,$10   ...L....
L06F0    fcb   $37,$30,$01,$9F,$8F,$17,$00,$CC   70.....L
L06F8    fcb   $10,$9F,$1F,$DC,$02,$DD,$05,$96   ...\.]..
L0700    fcb   $04,$97,$07,$CC,$00,$00,$DD,$42   ...L..]B
L0708    fcb   $17,$01,$14,$17,$00,$81,$30,$8D   ......0.
L0710    fcb   $F9,$84,$8D,$45,$30,$8D,$F8,$FD   y..E0.x.
L0718    fcb   $10,$8E,$00,$01,$10,$3F,$8A,$10   .....?..
L0720    fcb   $25,$05,$93,$30,$C9,$01,$D6,$17   %..0I.V.
L0728    fcb   $00,$BE,$A6,$84,$81,$41,$25,$02   .>&..A%.
L0730    fcb   $8A,$20,$30,$8D,$FE,$A3,$A1,$80   . 0..#!.
L0738    fcb   $27,$08,$30,$02,$6D,$84,$26,$F6   '.0.m.&v
L0740    fcb   $20,$C9,$0D,$2E,$27,$0B,$0D,$2D    I..'..-
L0748    fcb   $27,$07,$34,$12,$17,$04,$A1,$35   '.4...!5
L0750    fcb   $12,$EC,$84,$30,$8D,$F8,$A9,$6E   .l.0.x)n
L0758    fcb   $8B,$31,$C9,$01,$D6,$5F,$5C,$A6   .1I.V_\&
L0760    fcb   $80,$2B,$04,$A7,$A0,$20,$F7,$84   .+.'  w.
L0768    fcb   $7F,$A7,$A4,$30,$C9,$01,$D6,$4F   '$0I.VO
L0770    fcb   $1F,$02,$20,$04,$10,$8E,$00,$78   .. ....x
L0778    fcb   $86,$01,$10,$3F,$8C,$10,$25,$05   ...?..%.
L0780    fcb   $35,$39,$10,$8E,$00,$03,$4F,$10   59....O.
L0788    fcb   $3F,$8B,$10,$25,$05,$28,$39,$CC   ?..%.(9L
L0790    fcb   $20,$36,$30,$4A,$ED,$02,$10,$8E    60Jm...
L0798    fcb   $00,$04,$20,$DC,$30,$8D,$F8,$6E   .. \0.xn
L07A0    fcb   $10,$8E,$00,$02,$20,$D2,$30,$8D   .... R0.
L07A8    fcb   $F8,$67,$10,$8E,$00,$02,$20,$C8   xg.... H
L07B0    fcb   $30,$8D,$F8,$60,$10,$8E,$00,$01   0.x`....
L07B8    fcb   $20,$BE,$30,$8D,$F8,$4F,$10,$8E    >0.xO..
L07C0    fcb   $00,$01,$20,$B4,$8D,$2B,$30,$C9   .. 4.+0I
L07C8    fcb   $00,$D6,$9F,$12,$0D,$4D,$27,$0A   .V...M'.
L07D0    fcb   $DC,$23,$90,$04,$26,$04,$1F,$02   \#..&...
L07D8    fcb   $20,$04,$10,$8E,$01,$00,$96,$00    .......
L07E0    fcb   $10,$3F,$89,$10,$25,$04,$CF,$39   .?..%.O9
L07E8    fcb   $4F,$10,$8E,$00,$01,$10,$3F,$89   O.....?.
L07F0    fcb   $39,$0D,$4D,$26,$13,$9E,$02,$96   9.M&....
L07F8    fcb   $04,$5F,$1F,$03,$96,$00,$10,$3F   ._.....?
L0800    fcb   $88,$10,$25,$04,$B1,$DE,$1B,$39   ..%.1^.9
L0808    fcb   $DC,$23,$83,$00,$01,$91,$04,$24   \#.....$
L0810    fcb   $05,$C6,$D3,$16,$04,$A0,$DC,$08   .FS.. \.
L0818    fcb   $9B,$04,$8E,$00,$00,$20,$DB,$CC   ..... [L
L0820    fcb   $20,$20,$17,$FF,$6D,$30,$8D,$F8     ..m0.x
L0828    fcb   $15,$17,$FF,$2D,$8D,$82,$17,$00   ...-....
L0830    fcb   $B5,$30,$C9,$01,$D6,$17,$FF,$3C   50I.V..<
L0838    fcb   $0D,$4D,$27,$03,$17,$0B,$5B,$0D   .M'...[.
L0840    fcb   $01,$27,$03,$17,$04,$31,$CC,$20   .'...1L 
L0848    fcb   $22,$17,$FF,$46,$30,$8D,$F7,$BE   "..F0.w>
L0850    fcb   $10,$8E,$00,$02,$17,$FF,$23,$30   ......#0
L0858    fcb   $8D,$F7,$F2,$17,$FF,$16,$30,$8D   .wr...0.
L0860    fcb   $F7,$AF,$10,$8E,$00,$02,$17,$FF   w/......
L0868    fcb   $11,$17,$01,$20,$96,$0F,$8B,$10   ... ....
L0870    fcb   $97,$0F,$26,$F5,$30,$C9,$00,$D6   ..&u0I.V
L0878    fcb   $9F,$12,$0D,$8C,$27,$4C,$DC,$03   ....'L\.
L0880    fcb   $10,$83,$00,$01,$25,$44,$10,$93   ....%D..
L0888    fcb   $8F,$22,$3F,$DC,$03,$83,$00,$01   ."?\....
L0890    fcb   $8E,$08,$00,$17,$0E,$68,$1F,$20   .....h. 
L0898    fcb   $D7,$91,$DF,$92,$33,$C9,$07,$FF   W._.3I..
L08A0    fcb   $11,$93,$4A,$23,$0A,$D1,$49,$25   ..J#.QI%
L08A8    fcb   $06,$D6,$49,$DE,$4A,$33,$5F,$D7   .VI^J3_W
L08B0    fcb   $94,$DF,$95,$DE,$1B,$9E,$91,$D6   ._.^...V
L08B8    fcb   $93,$9F,$97,$D7,$99,$9E,$94,$D6   ...W...V
L08C0    fcb   $96,$9F,$9A,$D7,$9C,$17,$0E,$80   ...W....
L08C8    fcb   $20,$09,$CC,$20,$34,$17,$FE,$C2    .L 4..B
L08D0    fcb   $17,$FE,$DD,$0D,$2E,$10,$27,$FF   ..]...'.
L08D8    fcb   $2E,$CC,$59,$33,$17,$FE,$B3,$30   .LY3..30
L08E0    fcb   $8D,$F8,$9E,$16,$FE,$73,$DC,$02   .x...s\.
L08E8    fcb   $03,$18,$31,$C9,$01,$D6,$8D,$6D   ..1I.V.m
L08F0    fcb   $1F,$98,$8D,$69,$0F,$18,$96,$04   ...i....
L08F8    fcb   $8D,$63,$CC,$20,$20,$ED,$A1,$CC   .cL  m!L
L0900    fcb   $00,$08,$34,$06,$03,$18,$30,$8D   ..4...0.
L0908    fcb   $FC,$B7,$6F,$E4,$DC,$03,$A3,$01   .7od\.#.
L0910    fcb   $34,$01,$DD,$03,$96,$02,$5F,$A0   4.]..._ 
L0918    fcb   $84,$24,$01,$5C,$35,$01,$24,$02   .$.\5.$.
L0920    fcb   $80,$01,$97,$02,$24,$01,$5C,$5D   ....$.\]
L0928    fcb   $26,$04,$6C,$E4,$20,$DE,$DC,$03   &.ld ^\.
L0930    fcb   $E3,$01,$DD,$03,$96,$02,$24,$01   c.]...$.
L0938    fcb   $4C,$AB,$84,$97,$02,$30,$03,$8D   L+...0..
L0940    fcb   $43,$6A,$61,$27,$0A,$A6,$61,$81   Cja'.&a.
L0948    fcb   $02,$26,$BF,$0F,$18,$20,$BB,$86   .&?.. ;.
L0950    fcb   $0D,$A7,$A4,$DC,$06,$DD,$03,$96   .'$\.]..
L0958    fcb   $05,$97,$02,$35,$86,$34,$02,$44   ...5.4.D
L0960    fcb   $44,$44,$44,$8D,$07,$35,$02,$84   DDD..5..
L0968    fcb   $0F,$8D,$01,$39,$81,$09,$2F,$02   ...9../.
L0970    fcb   $8B,$07,$8B,$30,$A7,$A0,$0D,$18   ...0' ..
L0978    fcb   $27,$06,$81,$30,$27,$03,$0F,$18   '..0'...
L0980    fcb   $39,$31,$3F,$39,$34,$02,$A6,$63   91?94.&c
L0988    fcb   $8D,$E8,$35,$82,$31,$C9,$01,$D6   .h5.1I.V
L0990    fcb   $30,$8D,$F6,$7A,$17,$00,$9A,$96   0.vz....
L0998    fcb   $20,$27,$0A,$84,$F0,$91,$0F,$26    '..p..&
L09A0    fcb   $04,$86,$FF,$97,$11,$96,$0F,$8D   ........
L09A8    fcb   $B4,$86,$3A,$A7,$A0,$30,$8D,$F6   4.:' 0.v
L09B0    fcb   $60,$8D,$7E,$CC,$20,$20,$ED,$A1   `.~L  m!
L09B8    fcb   $9E,$12,$C6,$10,$0D,$11,$27,$08   ..F...'.
L09C0    fcb   $D6,$20,$C4,$0F,$27,$74,$34,$04   V D.'t4.
L09C8    fcb   $A6,$80,$8D,$91,$86,$20,$A7,$A0   &.... ' 
L09D0    fcb   $5A,$26,$F5,$0D,$11,$27,$0D,$CC   Z&u..'.L
L09D8    fcb   $03,$10,$E0,$E4,$3D,$86,$20,$A7   ..`d=. '
L09E0    fcb   $A0,$5A,$26,$FB,$C6,$20,$ED,$A1    Z&.F m!
L09E8    fcb   $A7,$A0,$9E,$12,$57,$0D,$11,$27   ' ..W..'
L09F0    fcb   $02,$E6,$E4,$A6,$80,$84,$7F,$81   .fd&...
L09F8    fcb   $20,$24,$02,$86,$2E,$A7,$A0,$5A    $...' Z
L0A00    fcb   $26,$F1,$9F,$12,$0D,$11,$27,$1E   &q....'.
L0A08    fcb   $C6,$10,$E0,$E0,$86,$20,$A7,$A0   F.``. ' 
L0A10    fcb   $5A,$26,$FB,$86,$F0,$97,$0F,$8D   Z&..p...
L0A18    fcb   $0D,$0F,$11,$30,$8D,$F5,$F6,$10   ...0.uv.
L0A20    fcb   $8E,$00,$01,$16,$FD,$52,$86,$0D   .....R..
L0A28    fcb   $A7,$A4,$30,$C9,$01,$D6,$16,$FD   '$0I.V..
L0A30    fcb   $43,$A6,$80,$27,$04,$A7,$A0,$20   C&.'.'  
L0A38    fcb   $F8,$39,$86,$F0,$97,$0F,$20,$D9   x9.p.. Y
L0A40    fcb   $DC,$03,$C3,$00,$01,$DD,$03,$26   \.C..].&
L0A48    fcb   $02,$0C,$02,$16,$FC,$A7,$DC,$03   .....'\.
L0A50    fcb   $26,$06,$0D,$02,$10,$27,$FC,$B3   &....'.3
L0A58    fcb   $83,$00,$01,$DD,$03,$10,$83,$FF   ...]....
L0A60    fcb   $FF,$26,$E8,$0A,$02,$20,$E4,$17   .&h.. d.
L0A68    fcb   $FD,$25,$30,$8D,$F5,$D5,$17,$FC   .%0.uU..
L0A70    fcb   $E8,$10,$8E,$00,$07,$8D,$12,$25   h......%
L0A78    fcb   $0B,$DC,$47,$DD,$03,$96,$46,$97   .\G]..F.
L0A80    fcb   $02,$16,$FC,$71,$17,$0A,$AE,$20   ...q... 
L0A88    fcb   $DE,$34,$20,$0F,$1A,$03,$1A,$17   ^4 .....
L0A90    fcb   $06,$63,$35,$20,$30,$C9,$01,$D6   .c5 0I.V
L0A98    fcb   $17,$FC,$EB,$0F,$1A,$17,$06,$55   ..k....U
L0AA0    fcb   $31,$3F,$27,$4A,$1F,$20,$A6,$80   1?'J. &.
L0AA8    fcb   $8D,$49,$25,$3F,$5A,$26,$F7,$10   .I%?Z&w.
L0AB0    fcb   $9F,$45,$86,$30,$E6,$82,$31,$3F   .E.0f.1?
L0AB8    fcb   $27,$04,$A6,$82,$31,$3F,$8D,$49   '.&.1?.I
L0AC0    fcb   $34,$04,$10,$8C,$00,$00,$26,$EA   4.....&j
L0AC8    fcb   $D6,$46,$5C,$54,$4F,$30,$C8,$45   VF\TO0HE
L0AD0    fcb   $C1,$04,$27,$0E,$A7,$80,$C1,$03   A.'.'.A.
L0AD8    fcb   $27,$08,$A7,$80,$C1,$02,$27,$02   '.'.A.'.
L0AE0    fcb   $A7,$80,$35,$02,$A7,$80,$5A,$26   '.5.'.Z&
L0AE8    fcb   $F9,$5F,$39,$17,$0A,$47,$32,$62   y_9..G2b
L0AF0    fcb   $16,$FC,$18,$81,$30,$25,$10,$81   ....0%..
L0AF8    fcb   $39,$23,$0A,$84,$5F,$81,$46,$22   9#.._.F"
L0B00    fcb   $06,$81,$41,$25,$02,$4F,$39,$43   ..A%.O9C
L0B08    fcb   $39,$8D,$0D,$34,$04,$1F,$89,$8D   9..4....
L0B10    fcb   $07,$58,$58,$58,$58,$EA,$E0,$39   .XXXXj`9
L0B18    fcb   $C0,$30,$C1,$09,$23,$04,$C4,$5F   @0A.#.D_
L0B20    fcb   $C0,$07,$39,$0F,$1A,$03,$1A,$17   @.9.....
L0B28    fcb   $05,$CB,$17,$FC,$62,$17,$FC,$80   .K..b...
L0B30    fcb   $30,$8D,$F5,$A7,$17,$FC,$22,$0D   0.u'..".
L0B38    fcb   $17,$26,$46,$30,$8D,$F5,$A0,$17   .&F0.u .
L0B40    fcb   $FC,$17,$10,$8E,$00,$03,$8D,$1A   ........
L0B48    fcb   $8D,$4C,$25,$2D,$30,$C9,$00,$D6   .L%-0I.V
L0B50    fcb   $9F,$12,$5F,$A7,$80,$5A,$26,$FB   .._'.Z&.
L0B58    fcb   $0F,$1A,$17,$05,$98,$0C,$2D,$16   ......-.
L0B60    fcb   $FB,$A6,$4F,$30,$C9,$01,$D6,$10   .&O0I.V.
L0B68    fcb   $3F,$8B,$25,$01,$39,$C1,$02,$10   ?.%.9A..
L0B70    fcb   $26,$01,$43,$03,$17,$32,$62,$20   &.C..2b 
L0B78    fcb   $AA,$0F,$1A,$17,$05,$77,$16,$FB   *....w..
L0B80    fcb   $8A,$30,$8D,$F5,$60,$17,$FB,$D1   .0.u`..Q
L0B88    fcb   $10,$8E,$00,$02,$8D,$D4,$A6,$84   .....T&.
L0B90    fcb   $81,$20,$25,$E5,$20,$B6,$8D,$12   . %e 6..
L0B98    fcb   $25,$2F,$1F,$89,$8D,$0C,$25,$29   %/....%)
L0BA0    fcb   $58,$58,$58,$58,$34,$04,$AA,$E0   XXXX4.*`
L0BA8    fcb   $20,$1A,$8D,$04,$25,$1B,$20,$1A    ...%. .
L0BB0    fcb   $A6,$80,$81,$30,$25,$11,$81,$39   &..0%..9
L0BB8    fcb   $23,$0A,$84,$5F,$81,$41,$25,$07   #.._.A%.
L0BC0    fcb   $81,$46,$22,$03,$1C,$FE,$39,$1A   .F"...9.
L0BC8    fcb   $01,$39,$80,$30,$81,$09,$23,$02   .9.0..#.
L0BD0    fcb   $80,$07,$20,$F0,$0D,$2E,$10,$26   .. p...&
L0BD8    fcb   $FB,$31,$8D,$23,$10,$26,$FB,$2B   .1.#.&.+
L0BE0    fcb   $17,$FB,$AC,$17,$FB,$CA,$17,$FB   ..,..J..
L0BE8    fcb   $A6,$30,$8D,$F5,$12,$17,$FB,$69   &0.u...i
L0BF0    fcb   $17,$FB,$FE,$96,$00,$17,$00,$92   ........
L0BF8    fcb   $0D,$2E,$27,$78,$0F,$2D,$39,$17   ..'x.-9.
L0C00    fcb   $FB,$8D,$0F,$1A,$03,$1A,$17,$04   ........
L0C08    fcb   $EC,$30,$8D,$F4,$DE,$17,$FB,$49   l0.t^..I
L0C10    fcb   $17,$FB,$9D,$30,$C9,$01,$D6,$17   ...0I.V.
L0C18    fcb   $FB,$CE,$0F,$1A,$17,$04,$D6,$A6   .N....V&
L0C20    fcb   $84,$84,$5F,$81,$59,$39,$0D,$01   .._.Y9..
L0C28    fcb   $26,$4A,$0F,$1A,$03,$1A,$17,$04   &J......
L0C30    fcb   $C4,$17,$FB,$5B,$30,$8D,$F4,$D8   D..[0.tX
L0C38    fcb   $17,$FB,$1E,$17,$FB,$72,$30,$C9   .....r0I
L0C40    fcb   $01,$D6,$10,$8E,$00,$1E,$17,$FB   .V......
L0C48    fcb   $3D,$0F,$1A,$17,$04,$A7,$10,$8C   =....'..
L0C50    fcb   $00,$01,$27,$20,$34,$10,$31,$C8   ..' 4.1H
L0C58    fcb   $6B,$A6,$80,$A7,$A0,$81,$20,$22   k&.' . "
L0C60    fcb   $F8,$86,$0D,$A7,$3F,$35,$10,$86   x..'?5..
L0C68    fcb   $02,$C6,$0B,$10,$3F,$83,$25,$46   .F..?.%F
L0C70    fcb   $97,$01,$8D,$03,$16,$FA,$94,$CC   .....z.L
L0C78    fcb   $30,$21,$17,$FB,$15,$30,$8D,$F4   0!...0.t
L0C80    fcb   $8F,$17,$FA,$D5,$30,$C8,$6B,$16   ..zU0Hk.
L0C88    fcb   $FA,$EA,$30,$C9,$00,$D6,$10,$9E   zj0I.V..
L0C90    fcb   $1F,$10,$3F,$8A,$25,$20,$39,$96   ..?.% 9.
L0C98    fcb   $01,$27,$D9,$10,$3F,$8F,$25,$16   .'Y.?.%.
L0CA0    fcb   $CC,$30,$21,$17,$FA,$EC,$17,$FB   L0!.zl..
L0CA8    fcb   $07,$0F,$01,$20,$C7,$96,$01,$27   ... G..'
L0CB0    fcb   $FA,$8D,$D7,$16,$FD,$8A,$34,$04   z.W...4.
L0CB8    fcb   $0F,$8B,$DC,$05,$DD,$02,$96,$07   ..\.]...
L0CC0    fcb   $97,$04,$35,$04,$10,$DE,$1D,$C1   ..5..^.A
L0CC8    fcb   $02,$27,$0C,$C1,$03,$26,$04,$0F   .'.A.&..
L0CD0    fcb   $2D,$20,$04,$C1,$D3,$26,$03,$16   - .AS&..
L0CD8    fcb   $FE,$9F,$C1,$CD,$26,$14,$0D,$4D   ..AM&..M
L0CE0    fcb   $26,$10,$8D,$1D,$30,$8D,$F3,$25   &...0.s%
L0CE8    fcb   $10,$8E,$00,$01,$17,$FA,$89,$16   .....z..
L0CF0    fcb   $FA,$16,$34,$04,$17,$FA,$98,$17   z.4..z..
L0CF8    fcb   $FA,$B6,$35,$04,$8D,$03,$16,$FA   z65....z
L0D00    fcb   $0A,$86,$02,$10,$3F,$0F,$0F,$1A   ....?...
L0D08    fcb   $17,$03,$EA,$30,$C9,$01,$D6,$16   ..j0I.V.
L0D10    fcb   $FA,$D6,$86,$02,$30,$8D,$F8,$94   zV..0.x.
L0D18    fcb   $10,$8E,$00,$78,$17,$FA,$5B,$5F   ...x.z[_
L0D20    fcb   $20,$12,$17,$FE,$DA,$10,$26,$F9    ...Z.&y
L0D28    fcb   $E2,$17,$FA,$8E,$96,$19,$97,$1A   b.z.....
L0D30    fcb   $17,$03,$C2,$5F,$10,$3F,$06,$17   ..B_.?..
L0D38    fcb   $FA,$55,$30,$8D,$F3,$5D,$17,$FA   zU0.s].z
L0D40    fcb   $18,$30,$C9,$00,$D6,$9F,$14,$86   .0I.V...
L0D48    fcb   $01,$97,$16,$86,$23,$97,$0F,$86   ....#...
L0D50    fcb   $25,$97,$0E,$86,$58,$97,$10,$17   %...X...
L0D58    fcb   $FA,$42,$17,$00,$EA,$96,$0E,$D6   zB..j..V
L0D60    fcb   $0F,$0D,$17,$27,$02,$96,$10,$0D   ...'....
L0D68    fcb   $8C,$10,$27,$00,$CA,$9E,$03,$8C   ..'.J...
L0D70    fcb   $00,$01,$10,$25,$00,$C1,$9C,$8F   ...%.A..
L0D78    fcb   $10,$22,$00,$BB,$34,$06,$9E,$91   .".;4...
L0D80    fcb   $D6,$93,$9F,$97,$D7,$99,$9E,$94   V...W...
L0D88    fcb   $D6,$96,$9F,$9A,$D7,$9C,$4F,$D6   V...W.OV
L0D90    fcb   $0F,$C0,$23,$86,$10,$3D,$34,$06   .@#..=4.
L0D98    fcb   $4F,$D6,$0E,$C0,$25,$27,$0A,$1F   OV.@%'..
L0DA0    fcb   $01,$CC,$00,$03,$17,$09,$81,$1F   .L......
L0DA8    fcb   $10,$E3,$E1,$9E,$03,$9C,$8F,$25   .ca....%
L0DB0    fcb   $12,$34,$06,$DC,$8D,$4F,$1F,$01   .4.\.O..
L0DB8    fcb   $35,$06,$30,$1F,$34,$10,$10,$A3   5.0.4..#
L0DC0    fcb   $E1,$22,$1A,$8E,$00,$08,$17,$09   a"......
L0DC8    fcb   $35,$1F,$30,$D3,$98,$DD,$98,$C3   5.0S.].C
L0DD0    fcb   $00,$07,$10,$93,$95,$23,$02,$DC   .....#.\
L0DD8    fcb   $95,$DD,$9B,$20,$06,$0F,$9A,$0F   .]. ....
L0DE0    fcb   $9B,$0F,$9C,$DE,$1B,$17,$F9,$BE   ...^..y>
L0DE8    fcb   $0D,$9C,$26,$13,$0D,$9B,$26,$0F   ..&...&.
L0DF0    fcb   $0D,$9A,$26,$0B,$CC,$20,$34,$17   ..&.L 4.
L0DF8    fcb   $F9,$98,$17,$F9,$B3,$20,$33,$17   y..y3 3.
L0E00    fcb   $09,$46,$CC,$49,$34,$17,$F9,$8A   .FLI4.y.
L0E08    fcb   $30,$8D,$F4,$1A,$17,$F9,$4A,$30   0.t..yJ0
L0E10    fcb   $C9,$00,$9D,$A6,$D8,$14,$C6,$08   I..&X.F.
L0E18    fcb   $34,$12,$68,$E4,$25,$04,$86,$30   4.hd%..0
L0E20    fcb   $20,$02,$86,$31,$A7,$80,$5A,$26    ..1'.Z&
L0E28    fcb   $F1,$35,$12,$10,$8E,$00,$08,$17   q5......
L0E30    fcb   $F9,$46,$17,$F9,$67,$35,$06,$17   yF.yg5..
L0E38    fcb   $F9,$58,$30,$C9,$01,$D6,$0D,$17   yX0I.V..
L0E40    fcb   $10,$26,$00,$F4,$16,$00,$B7,$96   .&.t..7.
L0E48    fcb   $0E,$D6,$0F,$17,$F9,$44,$31,$C9   .V..yD1I
L0E50    fcb   $01,$D6,$A6,$D8,$14,$34,$02,$17   .V&X.4..
L0E58    fcb   $FB,$03,$30,$3E,$10,$8E,$00,$02   ..0>....
L0E60    fcb   $86,$01,$17,$F9,$15,$96,$10,$D6   ...y...V
L0E68    fcb   $0F,$17,$F9,$26,$35,$02,$84,$7F   ..y&5..
L0E70    fcb   $81,$20,$24,$02,$86,$2E,$30,$C9   . $...0I
L0E78    fcb   $01,$D6,$A7,$84,$10,$8E,$00,$01   .V'.....
L0E80    fcb   $16,$F8,$F5,$34,$14,$4F,$C6,$01   .xu4.OF.
L0E88    fcb   $10,$3F,$8D,$24,$49,$C1,$F6,$26   .?.$IAv&
L0E90    fcb   $2E,$8E,$00,$01,$10,$3F,$0A,$25   .....?.%
L0E98    fcb   $26,$0A,$89,$96,$89,$98,$8A,$84   &.......
L0EA0    fcb   $40,$27,$12,$03,$8A,$27,$04,$8D   @'...'..
L0EA8    fcb   $1E,$20,$0A,$30,$8D,$F1,$6A,$10   . .0.qj.
L0EB0    fcb   $8E,$00,$02,$8D,$1A,$D6,$8B,$C1   .....V.A
L0EB8    fcb   $02,$27,$04,$C1,$03,$26,$C6,$E7   .'.A.&Fg
L0EC0    fcb   $E4,$8D,$04,$35,$14,$20,$1E,$30   d..5. .0
L0EC8    fcb   $8D,$F1,$4B,$10,$8E,$00,$02,$86   .qK.....
L0ED0    fcb   $01,$10,$3F,$8A,$5F,$39,$8D,$EF   ..?._9.o
L0ED8    fcb   $35,$14,$10,$8E,$00,$01,$4F,$10   5.....O.
L0EE0    fcb   $3F,$89,$25,$01,$39,$32,$62,$0F   ?.%.92b.
L0EE8    fcb   $8B,$C1,$02,$27,$0C,$34,$04,$17   .A.'.4..
L0EF0    fcb   $01,$28,$0F,$0F,$35,$04,$16,$FD   .(..5...
L0EF8    fcb   $BD,$03,$17,$16,$FE,$5F,$8D,$83   =...._..
L0F00    fcb   $8D,$1C,$25,$46,$17,$F8,$71,$E6   ..%F.xqf
L0F08    fcb   $84,$17,$FF,$77,$8D,$10,$25,$3A   ...w..%:
L0F10    fcb   $1E,$89,$17,$FB,$F4,$E7,$D8,$14   ....tgX.
L0F18    fcb   $86,$01,$97,$2D,$20,$57,$A6,$84   ...- W&.
L0F20    fcb   $81,$30,$25,$11,$81,$39,$23,$0A   .0%..9#.
L0F28    fcb   $84,$5F,$81,$46,$22,$07,$81,$41   ._.F"..A
L0F30    fcb   $25,$03,$1C,$FE,$39,$1A,$01,$39   %...9..9
L0F38    fcb   $17,$FF,$48,$A6,$84,$81,$20,$25   ..H&.. %
L0F40    fcb   $09,$A7,$D8,$14,$86,$01,$97,$2D   .'X....-
L0F48    fcb   $20,$2B,$81,$09,$27,$27,$81,$08    +..''..
L0F50    fcb   $27,$61,$81,$0C,$10,$27,$00,$C8   'a...'.H
L0F58    fcb   $81,$0A,$10,$27,$01,$18,$81,$0D   ...'....
L0F60    fcb   $10,$26,$FD,$F9,$17,$00,$B3,$CC   .&.y..3L
L0F68    fcb   $49,$34,$17,$F8,$25,$17,$F8,$40   I4.x%.x@
L0F70    fcb   $0F,$0F,$16,$F7,$96,$17,$00,$A2   ...w..."
L0F78    fcb   $0D,$20,$27,$08,$96,$16,$91,$20   . '.... 
L0F80    fcb   $10,$27,$FD,$BD,$DC,$14,$C3,$00   .'.=\.C.
L0F88    fcb   $01,$DD,$14,$0C,$16,$0C,$10,$96   .]......
L0F90    fcb   $10,$81,$68,$24,$09,$96,$0E,$8B   ..h$....
L0F98    fcb   $03,$97,$0E,$16,$FD,$B9,$0C,$0F   .....9..
L0FA0    fcb   $96,$0F,$81,$32,$10,$22,$FD,$99   ...2."..
L0FA8    fcb   $86,$25,$97,$0E,$86,$58,$97,$10   .%...X..
L0FB0    fcb   $16,$FD,$A4,$8D,$65,$DC,$14,$83   ..$.e\..
L0FB8    fcb   $00,$01,$DD,$14,$0A,$16,$0A,$10   ..].....
L0FC0    fcb   $96,$10,$81,$58,$25,$09,$96,$0E   ...X%...
L0FC8    fcb   $80,$03,$97,$0E,$16,$FD,$88,$0A   ........
L0FD0    fcb   $0F,$86,$52,$97,$0E,$86,$67,$97   ..R...g.
L0FD8    fcb   $10,$96,$0F,$81,$23,$25,$03,$16   ....#%..
L0FE0    fcb   $FD,$75,$9E,$14,$D6,$20,$27,$25   .u..V '%
L0FE8    fcb   $D7,$16,$4F,$30,$8B,$5A,$34,$04   W.O0.Z4.
L0FF0    fcb   $54,$54,$54,$54,$CB,$23,$D7,$0F   TTTTK#W.
L0FF8    fcb   $A6,$E0,$84,$0F,$34,$02,$8B,$58   &`..4..X
L1000    fcb   $97,$10,$35,$02,$C6,$03,$3D,$CB   ..5.F.=K
L1008    fcb   $25,$D7,$0E,$20,$08,$86,$32,$97   %W. ..2.
L1010    fcb   $0F,$30,$89,$01,$00,$9F,$14,$16   .0......
L1018    fcb   $FD,$3D,$17,$F7,$89,$16,$FE,$27   .=.w...'
L1020    fcb   $8D,$F8,$D6,$20,$27,$06,$96,$0F   .xV '...
L1028    fcb   $81,$23,$27,$23,$DC,$14,$83,$00   .#'#\...
L1030    fcb   $10,$DD,$14,$D6,$16,$C0,$10,$D7   .].V.@.W
L1038    fcb   $16,$0A,$0F,$96,$0F,$81,$23,$24   ......#$
L1040    fcb   $0B,$86,$32,$97,$0F,$DC,$14,$C3   ..2..\.C
L1048    fcb   $01,$00,$DD,$14,$16,$FD,$08,$C4   ..]....D
L1050    fcb   $F0,$96,$20,$84,$0F,$91,$16,$24   p. ....$
L1058    fcb   $02,$C0,$10,$4F,$34,$06,$DC,$14   .@.O4.\.
L1060    fcb   $E3,$E0,$DD,$14,$D6,$16,$EB,$E4   c`].V.kd
L1068    fcb   $D7,$16,$35,$04,$54,$54,$54,$54   W.5.TTTT
L1070    fcb   $CB,$23,$D7,$0F,$20,$D6,$8D,$A2   K#W. V."
L1078    fcb   $D6,$20,$27,$06,$D0,$16,$C1,$10   V '.P.A.
L1080    fcb   $25,$25,$DC,$14,$C3,$00,$10,$DD   %%\.C..]
L1088    fcb   $14,$96,$16,$8B,$10,$97,$16,$0C   ........
L1090    fcb   $0F,$96,$0F,$81,$32,$10,$23,$FC   ....2.#.
L1098    fcb   $BE,$DC,$14,$83,$01,$00,$DD,$14   >\....].
L10A0    fcb   $86,$23,$97,$0F,$16,$FC,$B0,$4F   .#....0O
L10A8    fcb   $D6,$16,$5A,$C4,$F0,$34,$06,$DC   V.ZDp4.\
L10B0    fcb   $14,$A3,$E0,$DD,$14,$D6,$16,$E0   .#`].V.`
L10B8    fcb   $E0,$D7,$16,$20,$E3,$17,$F6,$FA   `W. c.vz
L10C0    fcb   $96,$19,$97,$1A,$8D,$2F,$30,$8D   ...../0.
L10C8    fcb   $F0,$6C,$10,$8E,$00,$10,$33,$C9   pl....3I
L10D0    fcb   $01,$D6,$86,$0D,$A7,$C4,$CC,$00   .V..'DL.
L10D8    fcb   $00,$10,$3F,$03,$10,$25,$FB,$D6   ..?..%.V
L10E0    fcb   $10,$3F,$04,$DE,$1B,$30,$C9,$00   .?.^.0I.
L10E8    fcb   $D6,$9F,$12,$0F,$1A,$8D,$06,$17   V.......
L10F0    fcb   $F6,$C8,$16,$F6,$13,$34,$10,$32   vH.v.4.2
L10F8    fcb   $E8,$E0,$30,$E4,$4F,$5F,$10,$3F   h`0dO_.?
L1100    fcb   $8D,$10,$25,$FB,$B1,$96,$1A,$A7   ..%.1..'
L1108    fcb   $04,$4F,$10,$3F,$8E,$10,$25,$FB   .O.?..%.
L1110    fcb   $A5,$32,$E8,$20,$35,$90,$17,$F6   %2h 5..v
L1118    fcb   $76,$30,$8D,$EF,$FC,$17,$F6,$39   v0.o..v9
L1120    fcb   $CE,$00,$00,$8E,$00,$00,$9F,$25   N......%
L1128    fcb   $96,$00,$10,$3F,$88,$10,$25,$FB   ...?..%.
L1130    fcb   $85,$DE,$1B,$CC,$FF,$FF,$DD,$29   .^.L..])
L1138    fcb   $D7,$2B,$30,$C9,$01,$D6,$10,$8E   W+0I.V..
L1140    fcb   $00,$08,$96,$00,$10,$3F,$89,$10   .....?..
L1148    fcb   $25,$FB,$6B,$10,$8C,$00,$08,$10   %.k.....
L1150    fcb   $26,$00,$BB,$EC,$84,$81,$87,$10   &.;l....
L1158    fcb   $26,$00,$B3,$C1,$CD,$10,$26,$00   &.3AM.&.
L1160    fcb   $AD,$EC,$02,$10,$83,$00,$0F,$10   -l......
L1168    fcb   $23,$00,$A3,$83,$00,$03,$DD,$21   #.#...]!
L1170    fcb   $D3,$25,$DD,$25,$4F,$C6,$08,$A8   S%]%OF.(
L1178    fcb   $80,$5A,$26,$FB,$43,$A7,$84,$10   .Z&.C'..
L1180    fcb   $8E,$00,$01,$96,$00,$10,$3F,$8A   ......?.
L1188    fcb   $10,$25,$FB,$2A,$DC,$21,$83,$00   .%.*\!..
L1190    fcb   $09,$DD,$21,$30,$C9,$01,$D6,$10   .]!0I.V.
L1198    fcb   $8E,$00,$09,$8D,$64,$96,$00,$10   ....d...
L11A0    fcb   $8E,$00,$78,$10,$9C,$21,$23,$03   ..x..!#.
L11A8    fcb   $10,$9E,$21,$10,$3F,$89,$25,$5E   ..!.?.%^
L11B0    fcb   $10,$9F,$27,$8D,$4C,$DC,$21,$93   ..'.L\!.
L11B8    fcb   $27,$DD,$21,$26,$E0,$96,$00,$C6   ']!&`..F
L11C0    fcb   $05,$10,$3F,$8D,$1F,$30,$DE,$1B   ..?..0^.
L11C8    fcb   $10,$93,$25,$26,$41,$03,$29,$03   ..%&A.).
L11D0    fcb   $2A,$03,$2B,$30,$C8,$29,$10,$8E   *.+0H)..
L11D8    fcb   $00,$03,$96,$00,$10,$3F,$8A,$10   .....?..
L11E0    fcb   $25,$FA,$D3,$CC,$00,$03,$D3,$25   %zSL..S%
L11E8    fcb   $DD,$25,$C6,$06,$96,$00,$10,$3F   ]%F....?
L11F0    fcb   $8D,$10,$24,$FF,$3E,$C1,$D3,$10   ..$.>AS.
L11F8    fcb   $26,$FA,$BB,$17,$F5,$C6,$16,$F5   &z;.uF.u
L1200    fcb   $07,$33,$C8,$29,$10,$3F,$17,$10   .3H).?..
L1208    fcb   $25,$FA,$AB,$DE,$1B,$39,$CC,$20   %z+^.9L 
L1210    fcb   $36,$17,$F5,$7E,$30,$8D,$EF,$0D   6.u~0.o.
L1218    fcb   $17,$F5,$3E,$C6,$CD,$17,$FA,$E1   .u>FM.za
L1220    fcb   $16,$F4,$E8,$0D,$4D,$10,$26,$F4   .th.M.&t
L1228    fcb   $E2,$CC,$00,$00,$DD,$25,$DD,$23   bL..]%]#
L1230    fcb   $0F,$1A,$03,$1A,$17,$FE,$BE,$17   ......>.
L1238    fcb   $F5,$55,$17,$F5,$73,$30,$8D,$EE   uU.us0.n
L1240    fcb   $FA,$17,$F5,$15,$30,$C8,$4D,$10   z.u.0HM.
L1248    fcb   $8E,$00,$1E,$17,$F5,$38,$0F,$1A   ....u8..
L1250    fcb   $17,$FE,$A2,$10,$8C,$00,$01,$10   ..".....
L1258    fcb   $26,$00,$B1,$17,$F5,$5C,$0F,$4D   &.1.u\.M
L1260    fcb   $30,$8D,$EE,$ED,$17,$F5,$0D,$DC   0.nm.u.\
L1268    fcb   $23,$D3,$25,$DD,$25,$1F,$03,$8E   #S%]%...
L1270    fcb   $00,$00,$96,$00,$10,$3F,$88,$25   .....?.%
L1278    fcb   $7F,$DE,$1B,$30,$C9,$01,$D6,$10   ^.0I.V.
L1280    fcb   $8E,$00,$06,$10,$3F,$89,$25,$70   ....?.%p
L1288    fcb   $EC,$81,$81,$87,$26,$68,$C1,$CD   l...&hAM
L1290    fcb   $26,$64,$31,$C9,$01,$D6,$EC,$81   &d1I.Vl.
L1298    fcb   $DD,$23,$EC,$81,$34,$06,$DC,$25   ]#l.4.\%
L12A0    fcb   $8D,$44,$86,$20,$A7,$A0,$DC,$23   .D. ' \#
L12A8    fcb   $8D,$3C,$86,$20,$A7,$A0,$DC,$25   .<. ' \%
L12B0    fcb   $E3,$E1,$1F,$03,$8E,$00,$00,$96   ca......
L12B8    fcb   $00,$10,$3F,$88,$10,$25,$F9,$F6   ..?..%yv
L12C0    fcb   $DE,$1B,$1F,$21,$10,$8E,$00,$1D   ^..!....
L12C8    fcb   $96,$00,$10,$3F,$89,$10,$25,$F9   ...?..%y
L12D0    fcb   $E5,$A6,$80,$2A,$FC,$84,$7F,$A7   e&.*..'
L12D8    fcb   $1F,$86,$0D,$A7,$84,$30,$C9,$01   ...'.0I.
L12E0    fcb   $D6,$17,$F4,$90,$20,$81,$17,$F6   V.t. ..v
L12E8    fcb   $74,$1F,$98,$16,$F6,$6F,$C1,$D3   t...voAS
L12F0    fcb   $26,$06,$C6,$DD,$20,$02,$C6,$CD   &.F] .FM
L12F8    fcb   $0F,$4D,$C1,$D3,$10,$26,$F9,$B6   .MAS.&y6
L1300    fcb   $17,$F4,$E5,$30,$C9,$00,$D6,$9F   .te0I.V.
L1308    fcb   $12,$16,$FD,$E3,$10,$3F,$10,$10   ...c.?..
L1310    fcb   $25,$F9,$A3,$D7,$2C,$5A,$A6,$85   %y#W,Z&.
L1318    fcb   $8A,$80,$A7,$85,$9F,$29,$CE,$00   ..'..)N.
L1320    fcb   $00,$8E,$00,$00,$96,$00,$10,$3F   .......?
L1328    fcb   $88,$10,$25,$F9,$89,$DE,$1B,$30   ..%y.^.0
L1330    fcb   $C9,$01,$D6,$10,$8E,$00,$06,$10   I.V.....
L1338    fcb   $3F,$89,$25,$B2,$EC,$81,$81,$87   ?.%2l...
L1340    fcb   $26,$B4,$C1,$CD,$26,$B0,$EC,$81   &4AM&0l.
L1348    fcb   $DD,$23,$EC,$84,$D3,$25,$1F,$03   ]#l.S%..
L1350    fcb   $8E,$00,$00,$96,$00,$10,$3F,$88   ......?.
L1358    fcb   $25,$94,$DE,$1B,$30,$C9,$01,$D6   %.^.0I.V
L1360    fcb   $10,$8E,$00,$1D,$10,$3F,$89,$25   .....?.%
L1368    fcb   $85,$1F,$12,$9E,$29,$D6,$2C,$10   ....)V,.
L1370    fcb   $3F,$11,$24,$0A,$DC,$23,$D3,$25   ?.$.\#S%
L1378    fcb   $DD,$25,$1F,$03,$20,$A3,$86,$0D   ]%.. #..
L1380    fcb   $A7,$85,$5A,$A6,$85,$84,$7F,$A7   '.Z&..'
L1388    fcb   $85,$DC,$25,$DD,$08,$CC,$00,$06   .\%].L..
L1390    fcb   $30,$42,$A7,$80,$5A,$26,$FB,$16   0B'.Z&..
L1398    fcb   $F3,$5B,$CC,$30,$20,$17,$F3,$F2   s[L0 .sr
L13A0    fcb   $30,$8D,$ED,$CB,$17,$F3,$B2,$30   0.mK.s20
L13A8    fcb   $C8,$4D,$17,$F3,$C7,$CC,$58,$20   HM.sGLX 
L13B0    fcb   $17,$F3,$DF,$30,$8D,$ED,$C1,$17   .s_0.mA.
L13B8    fcb   $F3,$9F,$31,$C9,$01,$D6,$DC,$08   s.1I.V\.
L13C0    fcb   $17,$FF,$23,$86,$0D,$A7,$A4,$16   ..#..'$.
L13C8    fcb   $F3,$AE,$0D,$4D,$10,$27,$F3,$3B   s..M.'s;
L13D0    fcb   $CC,$00,$08,$30,$42,$A7,$80,$5A   L..0B'.Z
L13D8    fcb   $26,$FB,$CC,$30,$20,$17,$F3,$B2   &.L0 .s2
L13E0    fcb   $17,$F3,$CD,$17,$F3,$CA,$0F,$4D   .sM.sJ.M
L13E8    fcb   $16,$F3,$0A,$0D,$2E,$27,$0E,$0F   .s...'..
L13F0    fcb   $2E,$CC,$59,$33,$17,$F3,$9B,$17   .LY3.s..
L13F8    fcb   $F3,$B6,$16,$F3,$0E,$17,$F7,$FF   s6.s..w.
L1400    fcb   $26,$F8,$03,$2E,$CC,$59,$33,$17   &x..LY3.
L1408    fcb   $F3,$88,$30,$8D,$ED,$73,$17,$F3   s.0.ms.s
L1410    fcb   $48,$20,$E7,$17,$F3,$A4,$30,$8D   H g.s$0.
L1418    fcb   $EE,$24,$10,$8E,$03,$6E,$17,$F3   n$...n.s
L1420    fcb   $59,$30,$C9,$01,$D6,$17,$F3,$C0   Y0I.V.s@
L1428    fcb   $16,$FC,$C4,$0F,$1A,$03,$1A,$17   ..D.....
L1430    fcb   $FC,$C3,$17,$F3,$5A,$17,$F3,$78   .C.sZ.sx
L1438    fcb   $0D,$2F,$26,$35,$30,$8D,$ED,$54   ./&50.mT
L1440    fcb   $17,$F3,$16,$10,$8E,$00,$21,$17   .s....!.
L1448    fcb   $00,$CA,$10,$8C,$00,$01,$10,$27   .J.....'
L1450    fcb   $01,$07,$31,$3F,$1F,$20,$54,$10   ..1?. T.
L1458    fcb   $25,$00,$D3,$D7,$30,$33,$C8,$31   %.SW03H1
L1460    fcb   $17,$F7,$33,$10,$25,$00,$C7,$A7   .w3.%.G'
L1468    fcb   $C0,$31,$3E,$26,$F3,$DE,$1B,$20   @1>&s^. 
L1470    fcb   $25,$30,$8D,$ED,$31,$17,$F2,$E1   %0.m1.ra
L1478    fcb   $10,$8E,$00,$11,$17,$00,$95,$10   ........
L1480    fcb   $8C,$00,$01,$10,$27,$00,$D2,$1F   ....'.R.
L1488    fcb   $20,$5A,$D7,$30,$31,$C8,$31,$A6    ZW01H1&
L1490    fcb   $80,$A7,$A0,$5A,$26,$F9,$0F,$1A   .' Z&y..
L1498    fcb   $17,$FC,$5A,$30,$C9,$00,$D6,$D6   ..Z0I.VV
L14A0    fcb   $20,$31,$C8,$31,$A6,$A4,$A8,$80    1H1&$(.
L14A8    fcb   $10,$27,$00,$B0,$0D,$2F,$27,$06   .'.0./'.
L14B0    fcb   $85,$5F,$10,$27,$00,$A6,$5A,$26   ._.'.&Z&
L14B8    fcb   $EB,$34,$36,$4F,$C6,$01,$10,$3F   k46OF..?
L14C0    fcb   $8D,$25,$0D,$30,$C9,$01,$D6,$17   .%.0I.V.
L14C8    fcb   $F3,$1E,$A6,$84,$81,$05,$27,$76   s.&...'v
L14D0    fcb   $35,$36,$8D,$02,$20,$C9,$0D,$4D   56.. I.M
L14D8    fcb   $27,$09,$DC,$23,$83,$00,$01,$91   '.\#....
L14E0    fcb   $04,$27,$63,$DC,$03,$C3,$00,$01   .'c\.C..
L14E8    fcb   $DD,$03,$26,$02,$0C,$02,$17,$F3   ].&....s
L14F0    fcb   $00,$30,$C9,$00,$D6,$9F,$12,$0D   .0I.V...
L14F8    fcb   $4D,$27,$0A,$DC,$23,$90,$04,$26   M'.\#..&
L1500    fcb   $04,$1F,$02,$20,$04,$10,$8E,$01   ... ....
L1508    fcb   $00,$96,$00,$10,$3F,$89,$25,$30   ....?.%0
L1510    fcb   $10,$9F,$1F,$39,$30,$C9,$01,$D6   ...90I.V
L1518    fcb   $4F,$10,$3F,$8B,$25,$01,$39,$32   O.?.%.92
L1520    fcb   $62,$0F,$8B,$C1,$02,$10,$26,$F7   b..A..&w
L1528    fcb   $8D,$03,$2F,$16,$FE,$FD,$DE,$1B   ../...^.
L1530    fcb   $8D,$03,$16,$FE,$F6,$30,$8D,$EC   ....v0.l
L1538    fcb   $F2,$10,$8E,$00,$01,$16,$F2,$38   r.....r8
L1540    fcb   $C1,$D3,$10,$26,$F7,$70,$10,$DE   AS.&wp.^
L1548    fcb   $1D,$DC,$05,$DD,$02,$96,$07,$97   .\.]....
L1550    fcb   $04,$17,$F2,$70,$10,$9F,$1F,$8D   ..rp....
L1558    fcb   $DC,$16,$F6,$1D,$34,$04,$5A,$D7   \.v.4.ZW
L1560    fcb   $44,$9F,$42,$D6,$30,$5A,$27,$2F   D.BV0Z'/
L1568    fcb   $6A,$E4,$27,$1C,$31,$21,$A6,$A4   jd'.1!&$
L1570    fcb   $A8,$80,$27,$F1,$0D,$2F,$27,$04   (.'q./'.
L1578    fcb   $85,$5F,$27,$E9,$32,$61,$9E,$42   ._'i2a.B
L1580    fcb   $31,$C8,$31,$D6,$44,$16,$FF,$2F   1H1VD../
L1588    fcb   $32,$61,$34,$24,$17,$FF,$47,$35   2a4$..G5
L1590    fcb   $24,$96,$20,$34,$02,$20,$D5,$32   $. 4. U2
L1598    fcb   $61,$96,$04,$91,$07,$27,$21,$9C   a....'!.
L15A0    fcb   $42,$24,$15,$DC,$03,$83,$00,$01   B$.\....
L15A8    fcb   $DD,$03,$10,$83,$FF,$FF,$26,$02   ].....&.
L15B0    fcb   $0A,$02,$17,$F2,$0F,$10,$9F,$1F   ...r....
L15B8    fcb   $DC,$02,$DD,$05,$96,$04,$97,$07   \.].....
L15C0    fcb   $17,$F2,$5C,$DC,$42,$83,$00,$01   .r\\B...
L15C8    fcb   $DD,$14,$93,$12,$34,$04,$C4,$0F   ]...4.D.
L15D0    fcb   $34,$04,$CB,$58,$D7,$10,$35,$04   4.KXW.5.
L15D8    fcb   $86,$03,$3D,$CB,$25,$D7,$0E,$35   ..=K%W.5
L15E0    fcb   $04,$C4,$F0,$54,$54,$54,$54,$CB   .DpTTTTK
L15E8    fcb   $23,$D7,$0F,$17,$F1,$AE,$17,$F8   #W..q..x
L15F0    fcb   $56,$17,$F1,$B2,$0F,$0F,$16,$FF   V.q2....
L15F8    fcb   $60,$0D,$30,$10,$27,$F1,$0C,$17   `.0.'q..
L1600    fcb   $F1,$8D,$30,$8D,$EB,$B2,$17,$F1   q.0.k2.q
L1608    fcb   $50,$9E,$42,$10,$27,$FE,$87,$16   P.B.'...
L1610    fcb   $FF,$6E,$17,$F1,$7A,$30,$8D,$EB   .n.qz0.k
L1618    fcb   $AB,$17,$F1,$3D,$03,$18,$31,$C9   +.q=..1I
L1620    fcb   $01,$D6,$DC,$49,$17,$F3,$36,$1F   .V\I.s6.
L1628    fcb   $98,$17,$F3,$31,$DC,$4B,$17,$F3   ..s1\K.s
L1630    fcb   $2C,$0F,$18,$1F,$98,$17,$F3,$25   ,.....s%
L1638    fcb   $CC,$20,$20,$ED,$A1,$ED,$A1,$30   L  m!m!0
L1640    fcb   $C9,$01,$D6,$9F,$27,$1F,$20,$93   I.V.'. .
L1648    fcb   $27,$1F,$02,$17,$F1,$2A,$30,$8D   '...q*0.
L1650    fcb   $EB,$87,$17,$F1,$04,$10,$8E,$00   k..q....
L1658    fcb   $09,$17,$F4,$2D,$25,$B4,$CC,$20   ..t-%4L 
L1660    fcb   $37,$17,$F1,$2E,$17,$F5,$9B,$10   7.q..u..
L1668    fcb   $26,$F0,$A0,$9E,$45,$DE,$47,$C6   &p .E^GF
L1670    fcb   $02,$96,$00,$10,$3F,$8E,$10,$25   ....?..%
L1678    fcb   $F6,$3C,$9F,$49,$DF,$4B,$DE,$1B   v<.I_K^.
L1680    fcb   $96,$49,$91,$02,$25,$0C,$26,$07   .I..%.&.
L1688    fcb   $DC,$4A,$10,$93,$03,$23,$07,$16   \J...#..
L1690    fcb   $F0,$63,$97,$02,$DC,$4A,$0D,$4C   pc..\J.L
L1698    fcb   $26,$03,$83,$00,$01,$DD,$03,$10   &....]..
L16A0    fcb   $83,$FF,$FF,$26,$EA,$0A,$02,$20   ...&j.. 
L16A8    fcb   $E6,$96,$A5,$81,$10,$24,$24,$C6   f.%..$$F
L16B0    fcb   $03,$3D,$30,$C9,$00,$A6,$30,$85   .=0I.&0.
L16B8    fcb   $DC,$02,$ED,$81,$96,$04,$A7,$84   \.m...'.
L16C0    fcb   $0D,$A5,$27,$0A,$A1,$1D,$26,$06   .%'.!.&.
L16C8    fcb   $DC,$02,$A1,$1B,$27,$02,$0C,$A5   \.!.'..%
L16D0    fcb   $16,$F0,$38,$17,$F0,$B9,$30,$8D   .p8.p90.
L16D8    fcb   $EB,$51,$17,$F0,$7C,$17,$F1,$08   kQ.p|.q.
L16E0    fcb   $20,$EE,$96,$A5,$27,$EA,$C6,$03    n.%'jF.
L16E8    fcb   $3D,$C0,$03,$30,$C9,$00,$A6,$30   =@.0I.&0
L16F0    fcb   $85,$EC,$81,$DD,$02,$A6,$84,$97   .l.].&..
L16F8    fcb   $04,$0A,$A5,$16,$EF,$F7,$34,$76   ..%.ow4v
L1700    fcb   $6F,$64,$A6,$63,$3D,$ED,$66,$EC   od&c=mfl
L1708    fcb   $61,$3D,$EB,$66,$89,$00,$ED,$65   a=kf..me
L1710    fcb   $E6,$E4,$A6,$63,$3D,$E3,$65,$ED   fd&c=cem
L1718    fcb   $65,$24,$02,$6C,$64,$A6,$E4,$E6   e$.ld&df
L1720    fcb   $62,$3D,$E3,$64,$ED,$64,$35,$F6   b=cdmd5v
L1728    fcb   $34,$16,$86,$10,$34,$02,$4F,$5F   4...4.O_
L1730    fcb   $68,$64,$69,$63,$59,$49,$10,$A3   hdicYI.#
L1738    fcb   $61,$25,$04,$A3,$61,$6C,$64,$6A   a%.#aldj
L1740    fcb   $E4,$26,$ED,$AE,$63,$32,$65,$39   d&m.c2e9
L1748    fcb   $CC,$20,$34,$17,$F0,$44,$30,$8D   L 4.pD0.
L1750    fcb   $EA,$B0,$17,$F0,$04,$31,$C9,$01   j0.p.1I.
L1758    fcb   $D6,$34,$20,$DC,$97,$17,$F1,$FD   V4 \..q.
L1760    fcb   $1F,$98,$17,$F1,$F8,$96,$99,$17   ...qx...
L1768    fcb   $F1,$F3,$A6,$A2,$8A,$80,$A7,$A4   qs&"..'$
L1770    fcb   $CC,$32,$34,$17,$F0,$1C,$AE,$E4   L24.p..d
L1778    fcb   $17,$EF,$DE,$10,$AE,$E4,$DC,$9A   .o^..d\.
L1780    fcb   $17,$F1,$DA,$1F,$98,$17,$F1,$D5   .qZ...qU
L1788    fcb   $96,$9C,$17,$F1,$D0,$A6,$A2,$8A   ...qP&".
L1790    fcb   $80,$A7,$A4,$CC,$3D,$34,$17,$EF   .'$L=4.o
L1798    fcb   $F9,$35,$10,$17,$EF,$BB,$39,$29   y5..o;9)
L17A0    fcb   $9A,$3F                           .?

               ELSE

         nam   dEd OS-9 Disk Editor Version 2.01
         ttl   Copyright 1987 Doug DeMartinis

*******************************************************
* Copyright 1987 Doug DeMartinis; All Rights Reserved *
*                CIS:    72245,1400                   *
*                Delphi: DOUGLASD                     *
* Personal use and uploading of code, source and docs *
* to BBS's, as well as customization of the terminal  *
* display codes, is permitted only if the copyright   *
* notice and docs remain intact.                      *
*                                                     *
* 10/87 Various mods & fixes by Bruce Isted (BRI)     *
* 11/87 Added Diddle, Find, Push, Remove routines.    *
*       Fixed bug throwing stack off by going in and  *
*        out of various error routines.               *
*                                                     *
*******************************************************
*                                                     *
* Mods by Roger A. Krupski (HARDWAREHACK)             *
*                                                     *
* 02/88 -Added "enter" command which cleans up the    *
*        screen by running the REDO subroutine. (RAK) *
*                                                     *
* 01/90 -Added a check for the break key which allows *
*        aborting the <F>ind function. (RAK)          *
*       -Added a check for null filename in OUTFILE:  *
*        and bypass I$Create if so.                   *
*       -Other minor bugs fixed / errors trapped.     *
*******************************************************

         ifp1            
         use   defsfile
         endc            

type     set   prgrm+objct
revs     set   reent+1   

top      mod   dEdend,dEdnam,type,revs,start,size

**************************************************************************
* To customize dEd for another driver, change the value of 'xyflipr',    *
*    change co380 to FALSE and OTHER to TRUE, and make the appropriate   *
*    changes to the display codes in the block that begins 'ifne OTHER'. *
*    WordPak users only need to change co380 to FALSE and WPAK to TRUE.  *
**************************************************************************

* Set xyflipr to 1 if XY cursor move code has form: row,col
* Set    "    to 0 "   "   "     "    "    "   "    col,row
xyflipr  set   0          co380 uses $2,Col,Row to position cursor

* Change one of the following lines to TRUE and others to FALSE,
*  depending on which 80 column display you're using.

co380    set   FALSE      Set to TRUE if using Mike Dziedzic's co380 driver
WPAK     set   FALSE      Set to TRUE if using WordPak
OTHER    set   TRUE       Set to TRUE for another driver and change codes below

* Conditional assembly of terminal commands depending on previous choices:

         ifne  OTHER     
* e.g. CoCo 3, OS-9 Level II
* Change the appropriate byte strings below for another driver

xyflipr  set   0          Change to 1 if XY Cursor move code wants form Row,Col
curscode set   $2         XY Cursor move code (max length=2 bytes)
cls      fcb   $c         Clear Screen byte string
clschrs  equ   *-cls      Don't change this.
revvid   fcb   $1F,$20,0  Reverse Video byte string. Must end with a 0.
revchrs  equ   *-revvid-1 Don't change this.
normvid  fcb   $1F,$21,0  Normal Video byte string. MUST end with a 0.
normchrs equ   *-normvid-1 Don't change this.
eraselin fcb   4          Erase to End of Line byte string.
eraschrs equ   *-eraselin Don't change this.
erasescr fcb   $b         Erase to End of Screen byte string.
era2chrs equ   *-erasescr Don't change this.

* modification by BRI
* adds cursor on/off strings & string lengths
CursrOn  fcb   $05,$21,0  Cursor on string.  MUST end with a 0.
CursOn   equ   *-CursrOn-1 Don't change this.
CursrOff fcb   $05,$20,0  Cursor off string.  MUST end with a 0.
CursOff  equ   *-CursrOff-1 Don't change this.
* end modification

         endc            

         ifne  WPAK      
* This is for WordPak driver

xyflipr  set   1          cursor move wants row,col
curscode set   $2         XY cursor move code
cls      fcb   $c         clear screen code
clschrs  equ   *-cls     
revvid   fcb   $1b,$53,$21,0 reverse video toggle
revchrs  equ   *-revvid-1 # chars in code string
normvid  fcb   $1b,$53,$20,0 normal video toggle
normchrs equ   *-normvid-1
eraselin fcb   $1b,$41    erase to end of line
eraschrs equ   *-eraselin
erasescr fcb   $1b,$42    erase to end of screen
era2chrs equ   *-erasescr

* modification by BRI
* adds cursor on/off strings & string lengths
CursrOn  fcb   0          Cursor on string.  MUST end with a 0.
CursOn   equ   *-CursrOn-1 Don't change this.
CursrOff fcb   0          Cursor off string.  MUST end with a 0.
CursOff  equ   *-CursrOff-1 Don't change this.
* end modification

         endc            

         ifne  co380     
* This is for co380 driver for CoCo3
xyflipr  set   0          cursor move wants col,row
curscode set   $2         1st byte of move cursor code
cls      fcb   $c         clear screen code
clschrs  equ   *-cls     
revvid   fcb   0          reverse video not supported by co380
revchrs  equ   *-revvid-1 # chars in code string
normvid  fcb   0          Reverse video off not supported by co380
normchrs equ   *-normvid-1
eraselin fcb   4          erase to end of line
eraschrs equ   *-eraselin
erasescr fcb   $b         erase to end of screen
era2chrs equ   *-erasescr

* modification by BRI
* adds cursor on/off strings & string lengths
CursrOn  fcb   0          Cursor on string.  MUST end with a 0.
CursOn   equ   *-CursrOn-1 Don't change this.
CursrOff fcb   0          Cursor off string.  MUST end with a 0.
CursOff  equ   *-CursrOff-1 Don't change this.
* end modification

         endc            

***********************************************************************
* All the changes for customizing dEd should be done above this line. *
***********************************************************************


* Don't change the following 2 blocks.
* X,Y coordinates of various screen prompts
         ifne  xyflipr   
hedrpos  set   $2220      Header position (row/col)
cmdpos   set   $3620      Command position
cmd1pos  set   $3720      Command position + 1 row
outpos   set   $2130      Output pathlist position
modpos   set   $2030      Module name position
offpos   set   $2058      Offset position
xprtpos  set   $3435      EXPERT position

         else            

hedrpos  set   $2022     
cmdpos   set   $2036      Command position
cmd1pos  set   $2037      Command position + 1 row
outpos   set   $3021      Output pathlist position
modpos   set   $3020      Module name position
offpos   set   $5820      Offset position
xprtpos  set   $3534      EXPERT position
         endc            

****************************
* Variable Storage
****************************

bufsiz   equ   120       
MaxStack equ   16         maximum # sectors that can be 'pushed' onto stack

inpath   rmb   1          input path #
outpath  rmb   1          output path #
lsn      rmb   3          Logical Sector number
oldlsn   rmb   3          LSN backup
offset   rmb   2          'Linked' module offset
cursor   rmb   4          Move cursor code
hexcol   rmb   1          Hex dump column #
rownum   rmb   1          Row number (Hex 0-f)
asciicol rmb   1          ASCII dump col #
lastflag rmb   1          Flag for last line display
buffptr  rmb   2          Pointer for input buffer
edbufptr rmb   2          Edit buffer pointer
edpos    rmb   1          Edit position counter for partial sector reads
hexascii rmb   1          hex/ascii edit mode flag; 0=>Hex, FF=>ASCII
zeroflag rmb   1          leading zero suppression flag, $FF=>Suppress
oldecho  rmb   1          original echo status
echobyte rmb   1          current echo status
Usave    rmb   2          U register storage
Ssave    rmb   2          S register storage
seclen   rmb   2          sector length ($100 unless last LSN in file)
vmodlen  rmb   2          Verify module length
lmodlen  rmb   2          'Linked' module length
fileln   rmb   2          cumulative file length
bytsread rmb   2          bytes read during verify
CRC      rmb   3          CRC accumulator for verify
modnmlen rmb   1          'Link' module name length
wrtflag  rmb   1          Flag to auto-write sector
xprtflag rmb   1          Expert mode flag
FHexAsc  rmb   1          'Find' Hex/Ascii mode flag
targlen  rmb   1          length of string to find
findstr  rmb   17         string to 'Find'
FindPtr  rmb   2          pointer to byte to start next search at
FBytes   rmb   1          # bytes left in target string
HexBuff  rmb   4          scratch area for ASCII to Hex conversions
FileLen  rmb   4          File length
infile   rmb   30         linked module name
outfile  rmb   30         Output filename

* modification by BRI
CrsrCnt  rmb   1          8-bit cursor toggle counter (bit 3 active)
CrsrFlg  rmb   1          cursor toggle (initialized to 0)
SgnlCode rmb   1          intercept routine signal code
* end modification

StackCnt rmb   1          # sectors on stack
Stack    rmb   3*MaxStack room for 16 LSN's

inbuff   rmb   256        input buffer
i.o.buff rmb   bufsiz     input/output buffer
         rmb   200        stack storage 
size     equ   .          end of data area

dEdnam   fcs   /dEd/     
         fcb   3          version
         fcc   /Copyright 1987 Doug DeMartinis/

* Display messages

lsntitle fcs   /LSN=$/   
sect     fcs   /SECTOR = $/
header   fcc   /      0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F    0 2 4 6 8 A C E /
         fcb   $d        
command  fcs   /CMD: /   
edprompt fcs   "<BREAK> toggles HEX/ASCII edit modes     <ENTER> exits edit mode"
zaprompt fcs   /Zap /    
byte     fcs   /byte: /  
char     fcs   /char: /  
sure     fcs   "Are you sure? (Y/N) "
writing  fcs   /Writing sector.../
out$     fcs   /OUTFILE: /
vrfymess fcs   /Verifying.../
verrmess fcs   /Verify aborted.../
shell$   fcs   /shell/   
linkmess fcs   /Link to which module? /
linkhdr  fcc   /Off  Len  Name/
         fcb   $a        
         fcc   /---- ---- ----/
         fcb   $d        
modnmhdr fcs   /MODULE:  /
offmess  fcs   /OFFSET: $/
xprtmess fcb   $1f,$24    cc3 blink on
         fcc   /- Expert Mode -/
         fcb   $1f,$25+$80 blink off
findbyte fcs   /Find byte string $/
findchar fcs   /Find char string: /
srchmess fcs   /Searching.../
lenmess  fcs   /Current File Length $/
newmess  fcs   /New Length? $/
fullmess equ   *         
bell     fcb   7         
         fcs   /Sector Stack Full /

* modification by BRI
* alphabetized help list,
* removed redundant 'Close' message,
* added prompt at end
helper   fcc   "   Up/Down Arrows  Read & display Next/Previous sector"
         fcb   $a,$a     
         fcc   / <CR> Clean up the screen display/
         fcb   $a        
         fcc   /   $  Fork a SHELL (Ctrl-BREAK to return)/
         fcb   $a        
         fcc   /   A  Append displayed sector to output file/
         fcb   $a        
         fcc   /   C  Close output file/
         fcb   $a        
         fcc   /   D  Diddle (adjust) file length/
         fcb   $a        
         fcc   /   E  Edit the displayed sector/
         fcb   $a        
         fcc   /   F  Find a byte or text string (BREAK aborts)/
         fcb   $a        
         fcc   /   H  Help screen (also use '?')/
         fcb   $a        
         fcc   /   L  Link to a module - List all modules/
         fcb   $a        
         fcc   /   N  Next occurrence of byte(s) or string (Find)/
         fcb   $a        
         fcc   /   O  Open a file for output (use with Append)/
         fcb   $a        
         fcc   /   P  Push current sector onto stack/
         fcb   $a        
         fcc   /   Q  Quit dEd - Exit to OS9/
         fcb   $a        
         fcc   /   R  Remove and display a sector from stack/
         fcb   $a        
         fcc   /   S  Skip to given sector (sector # in hex)/
         fcb   $a        
         fcc   /   U  Unlink from module/
         fcb   $a        
         fcc   /   V  Verify all modules in file/
         fcb   $a        
         fcc   /   W  Write the sector back to the disk/
         fcb   $a        
         fcc   "   X  eXpert mode toggle on/off"
         fcb   $a        
         fcc   /   Z  Zap (fill in) the sector displayed/
         fcb   $a,$a     
         fcc   /      (Press any key to return to command prompt):/
*fcb $a
helpchrs equ   *-helper  
* end modifications

hints    fcc   /Use:  dEd <pathlist>/
         fcb   $0d       

* Table for converting Hex to Decimal

decimals fcb   $98,$96,$80 Decimal 10,000,000
         fcb   $0f,$42,$40 Decimal 1,000,000
         fcb   $01,$86,$A0 Decimal 100,000
         fcb   $00,$27,$10 Decinal 10,000
         fcb   $00,$03,$E8 Decimal 1,000
         fcb   $00,$00,$64 Decimal 100
         fcb   $00,$00,$0A Decimal 10
         fcb   $00,$00,$01 etc.

commands fcb   $c         up arrow
         fdb   nxtsec    
         fcb   $a         down arrow
         fdb   prevsec   
         fcb   '$         shell
         fdb   goshell   
         fcb   $d         c/r clean up screen
         fdb   redo      
         fcb   's         LSN change
         fdb   changLSN  
         fcb   'z         zap
         fdb   zap       
         fcb   'w         write sector
         fdb   writesec  
         fcb   'o         open output file
         fdb   openout   
         fcb   'a         append to out file
         fdb   append    
         fcb   'c         close out file
         fdb   closeout  
         fcb   'e         edit sector
         fdb   edit      
         fcb   'q         quit
         fdb   quit      
         fcb   'v         verify
         fdb   verify    
         fcb   'l         'link' to module
         fdb   linker    
         fcb   'u         'unlink' module
         fdb   unlinker  
         fcb   'x         Expert mode
         fdb   expert    
         fcb   'h         Help
         fdb   help      
         fcb   '?        
         fdb   help      
         fcb   'f        
         fdb   find      
         fcb   'n        
         fdb   next      
         fcb   'd        
         fdb   diddle    
         fcb   'p        
         fdb   push      
         fcb   'r        
         fdb   remove    
         fcb   0          end of table

* Intercept signals
* modification by BRI
*icept  rti
icept    stb   SgnlCode,u save signal code
         rti             
* end modification


start    equ   *          entry point

         stx   inbuff     save pointer to param
         leax  icept,pcr  intercept routine addr
         os9   f$icpt     set up intercept
         lbcs  error     

* Initialize data area

         clra            
         ldb   #inbuff    # bytes to clear
         leax  ,u         point X to start of data area
init     sta   ,x+        zero memory
         decb             dec counter
         bne   init       loop if not done
         stu   Usave      save U register
         sts   Ssave      save Stack pointer

setcurs  ldd   #curscode  cursor move code
         std   cursor     save it for output
         leas  -32,s      make room for terminal options
         leax  ,s         point x to 32 byte buffer
         clra             path = 0 (stdin)
         clrb             (SS.OPT - option status)
         os9   i$getstt   read in option table
         lbcs  error     
         lda   4,x        get echo status byte
         sta   oldecho    save it
         leas  32,s       reset stack

* Open file

         ldx   inbuff     pointer to file name
         lda   #updat.    mode=update
         os9   i$open     open file

* modification by BRI
* lbcs bye exit if error
         bcc   OpenOK    
         cmpb  #E$FNA     no permission?
         lbne  bye        no, go exit with error
         ldx   inbuff     pointer to file name
         lda   #DIR.+UPDAT. mode=directory+update
         os9   I$Open     open file
         lbcs  bye        exit if error
OpenOK   equ   *         
* end modification

         sta   inpath     save input path #
         ldb   #ss.size  
         os9   i$getstt   get file size
         stx   FileLen    save
         stu   FileLen+2 
         ldu   Usave      restore U
         clr   echobyte   no echo flag
         lbsr  echo       set echo status
         lbsr  clrscr     go clear screen

* Main Read/Display loop

readloop lbsr  seeksec    find sector & read it
         sty   seclen     bytes read ($100 unless last LSN in file)
         ldd   lsn        get lsn just read
         std   oldlsn     & save it
         lda   lsn+2      for retrieval
         sta   oldlsn+2   after read errors
         ldd   #0         Signal 'Next' command to start
         std   findptr    search at start of LSN
disploop lbsr  display    go display sector
getcmd   lbsr  movecmd    move cursor
         leax  command,pcr point to 'CMD: '
         bsr   pstring    display line
         leax  erasescr,pcr erase to end of screen
         ldy   #era2chrs 
         os9   i$write   
         lbcs  error     
         leax  i.o.buff,u point to buffer to read into
         lbsr  read1      read a char from stdin
         lda   ,x         get char read
         cmpa  #'A        alpha char?
         blo   srchtabl   no, leave it alone
         ora   #$20       else UPPER -> lower case
srchtabl leax  commands,pcr point to command table
findcmd  cmpa  ,x+        got command?
         beq   gotcmd     yes, bra
         leax  2,x        else, skip address
         tst   ,x         end of table?
         bne   findcmd    no, loop back
         bra   getcmd     key invalid, exit
gotcmd   tst   xprtflag   expert mode?
         beq   jmpcmd     no, bra
         tst   wrtflag    need to write buffer out
         beq   jmpcmd     no, bra
         pshs  x,a       
         lbsr  xprtwrt    write sector
         puls  a,x       
jmpcmd   ldd   ,x         get address offset
         leax  top,pcr    start of module
         jmp   d,x        jump to offset addr


* Print string of characters having bit 7 of last char set

pstring  leay  i.o.buff,u output buffer
         clrb             counter
xfer     incb            
         lda   ,x+        get char
         bmi   lstchar    bra if bit 7 set
         sta   ,y+        put in buffer
         bra   xfer       get more
lstchar  anda  #$7f       clr bit 7
         sta   ,y         put in buffer
         leax  i.o.buff,u point to char string
         clra            
         tfr   d,y        y= length of string
         bra   writeout  

wrtlin1  ldy   #bufsiz    write 200 chars max
writeout lda   #1         stdout
wrtlin2  os9   i$writln   write line
         lbcs  error     
         rts             

readlin3 ldy   #3         # chars to read
readlin  clra             stdin
         os9   i$readln   read in Y-1 chars + CR
         lbcs  error     
         rts             

movecmd  ldd   #cmdpos   
movecurs leax  cursor,u   point to cursor move code
         std   2,x        save row/col
         ldy   #4         4 chars
         bra   writeout  

* Set display to reverse video

revdisp  leax  revvid,pcr point to code
         ldy   #revchrs   # chars
         bra   writeout   write to stdout

* Set display to normal video

normdisp leax  normvid,pcr point to code
         ldy   #normchrs  # chars
         bra   writeout   write to stdout


clrline  leax  eraselin,pcr point to erase line code
         ldy   #eraschrs  # chars
         bra   wrtlin2    go erase rest of line & return

clrscr   leax  cls,pcr    point to clear screen code
         ldy   #clschrs   #chars
         bra   writeout   clear screen & return

seeksec  bsr   lsnseek    seek to sector
         leax  inbuff,u   point to buffer
         stx   buffptr    save pointer
         tst   infile     module linked?
         beq   read256    no, bra
         ldd   lmodlen    linked mod length
         suba  lsn+2      >$100 bytes left?
         bne   read256    yes, bra
         tfr   d,y        no, set up for smaller read
         bra   readsome  
read256  ldy   #$100      read 256 bytes
readsome lda   inpath     path #
read     os9   i$read     read them in
         lbcs  error     
         rts             

******************************
* changed to ignore errors 01/09/90 (RAK)
*
read1                    
         clra             stdin
         ldy   #1         get 1 byte
         os9   I$Read     get 1 byte
         rts              ignore any errors
* bra read
****************************** END of modification

lsnseek  tst   infile     module linked?
         bne   offchk     yes, bra
         ldx   lsn        x=lsn MS 16 bits
         lda   lsn+2      get 3rd byte of lsn
         clrb            
lsnseek1 tfr   d,u        u=LS 16 bits
         lda   inpath     get input path #
         os9   i$seek     seek lsn
         lbcs  error     
         ldu   usave      restore U
lsnrts   rts             

offchk   ldd   lmodlen    linked mod length
         subd  #1         now A=LSN of last sector
         cmpa  LSN+2      trying to read past last sector?
         bhs   offseek    no, bra
         ldb   #e$eof     yes, set EOF error
         lbra  error     
* If module is 'linked' must add offset to functional LSN ->true seek count
offseek  ldd   offset    
         adda  lsn+2      offset + 'LSN'
         ldx   #0        
         bra   lsnseek1   seek to 'LSN'

display  ldd   #$2020    
         lbsr  movecurs  
         leax  lsntitle,pcr point to "lsn..."
         lbsr  pstring   
         bsr   clrline    clear rest of line
         bsr   convert3   convert lsn to ascii/dec
         leax  i.o.buff,u
         lbsr  wrtlin1   

         tst   infile     is a module 'linked'?
         beq   nolink     no, bra
         lbsr  prntmod    yes, display name

nolink   tst   outpath    is an output file open?
         beq   noout      no, bra
         lbsr  prntout    yes, print name

noout    ldd   #hedrpos   get header row/col
         lbsr  movecurs   move cursor
         leax  revvid,pcr point to reverse video code
         ldy   #revchrs   # chars
         lbsr  wrtlin2   
         leax  header,pcr point to header
         lbsr  wrtlin1    display it
         leax  normvid,pcr point to normal vid code
         ldy   #normchrs  # chars
         lbsr  wrtlin2    write code out
disp     lbsr  dsplylin  
         lda   rownum     get row #
         adda  #$10       next row
         sta   rownum     save it
         bne   disp       do 16 rows
         leax  inbuff,u  
         stx   buffptr    reset buffer pointer
         tst   xprtflag   Expert mode?
         beq   lsnrts     no, return
         ldd   #xprtpos  
         lbsr  movecurs  
         leax  xprtmess,pcr
         lbra  pstring    display 'EXPERT' & return

* Convert 3 HEX bytes to ASCII

convert3 ldd   lsn        get 2 MSB's of LSN
         com   zeroflag   suppresw leading zeroes
         leay  i.o.buff,u point to output buffer
         bsr   convert1   convert byte in A to ascii
         tfr   b,a       
         bsr   convert1   and convert 2nd byte
         clr   zeroflag   stop suppressing leading 0's
         lda   lsn+2      get LSB of LSN
         bsr   convert1   and convert it
         ldd   #$2020     2 space
         std   ,y++       put in out buffer

*   Output LSN as decimal number

         ldd   #$0008     8 dec digits max, 0=counter
         pshs  d          save them
         com   zeroflag   suppress leading zeroes
         leax  decimals,pcr point to conversion table
initsub1 clr   ,s         set counter = 0
subdec1  ldd   lsn+1      get LSB's of LSN
         subd  1,x        subtract LSB's of table entry
         pshs  cc         save 'carry'
         std   lsn+1      save result
         lda   lsn        get MSB
         clrb             flag for enough subtractions
         suba  ,x         subtract MSB of LSN
         bcc   LSBborow   if no 'borrow', see if LSB sub needed borrow
         incb             else, enough subs done
LSBborow puls  cc         restore LSB 'borrow' flag
         bcc   savemsb    save byte if borrow not needed
         suba  #1         else do borrow, setting flags
savemsb  sta   lsn        save MSB
         bcc   chekenuf   bra if no borrow needed by last dec
         incb             else set flag ->enuf subs done
chekenuf tstb             enuf subs done?
         bne   enufsub1   Yes, bra
         inc   ,s         else, inc decimal counter
         bra   subdec1    and do more subtractions
enufsub1 ldd   lsn+1      get value
         addd  1,x        make it positive again
         std   lsn+1      and save
         lda   lsn        get MSB
         bcc   addmsb     'Carry' bit still valid from 'addd 1,x'
         inca             do carry from LSB's
addmsb   adda  ,x         make rest of remainder positive
         sta   lsn        and save it for next round of sub
         leax  3,x        point X to next table entry
         bsr   decascii   go convert decimal counter to ascii
         dec   1,s        dec counter (8 digits)
         beq   getCR      Yes, exit
         lda   1,s        down to last 2 digits?
         cmpa  #2        
         bne   initsub1   no, loop back
         clr   zeroflag   else stop suppressing leading 0's
         bra   initsub1  

getCR    lda   #$d        <CR>
         sta   ,y         put in out string
         ldd   oldlsn+1   restore LSN
         std   lsn+1     
         lda   oldlsn    
         sta   lsn       
         puls  d,pc      

* Convert HEX byte in A to ASCII and put in buffer (Y)

convert1 pshs  a          save byte
         lsra             shift msn to lsnibble
         lsra            
         lsra            
         lsra            
         bsr   objasc    
         puls  a          get byte back
         anda  #$0f       mask off msb
         bsr   objasc     convert if to ascii
         rts             
objasc   cmpa  #9         digit?
         ble   asciify    yes, make it ascii
         adda  #7        
asciify  adda  #$30       makes it ascii
         sta   ,y+        and put it in buffer
         tst   zeroflag   suppressing leading zeroes?
         beq   convdone   no, exit
         cmpa  #'0        was it a zero?
         beq   suppres0   Yes, go 'erase' it
         clr   zeroflag   No, so stop suppressing 0's
convdone rts             
suppres0 leay  -1,y       reset pointer back over zero
         rts             

* Convert object decimal # on stack to ASCII & put in buffer (Y)

decascii pshs  a          save this
         lda   3,s        get decimal counter
         bsr   asciify    make it ascii
         puls  a,pc       get byte back & return


dsplylin leay  i.o.buff,u point to output buffer
         leax  revvid,pcr
         lbsr  transfer   put in reverse video code
         lda   seclen+1   LSB of # bytes read
         beq   notlast    skip ahead if 0 (seclen=$100)
         anda  #$f0       mask off LSB
         cmpa  rownum     current display row = last?
         bne   notlast    no, go on
         lda   #$ff      
         sta   lastflag   signal last line
notlast  lda   rownum     get row number
         bsr   convert1   convert it to hex byte
         lda   #':       
         sta   ,y+       
         leax  normvid,pcr point to code
         bsr   transfer   move code to buffer
         ldd   #$2020     spaces
         std   ,y++      
         ldx   buffptr    get buffer pointer
         ldb   #$10       16 bytes
         tst   lastflag   last line?
         beq   cnvrtbyt   no, bra
         ldb   seclen+1   bytes read
         andb  #$0f       now B=bytes for lst line
         beq   noline     bra if no bytes left
         pshs  b          save this
cnvrtbyt lda   ,x+        get byte from buffer
         bsr   convert1   convert it to hex
         lda   #$20       space
         sta   ,y+        put in output buffer
         decb             done?
         bne   cnvrtbyt   No, do more
         tst   lastflag   lst line?
         beq   addspc2    no, bra
         ldd   #$0310     B=max bytes on line
         subb  ,s         b=# bytes to null out
         mul              3 spaces per byte
         lda   #$20       space
addspc1  sta   ,y+        put in buffer
         decb             done?
         bne   addspc1   
addspc2  ldb   #$20       space
         std   ,y++      
         sta   ,y+        output spaces
         ldx   buffptr    get buff pointer again
         asrb             b=$10 (16 bytes)
         tst   lastflag   lst line?
         beq   ascichar   no, bra
         ldb   ,s         yes, get # bytes from prior calc
ascichar lda   ,x+        get byte
         anda  #$7f       clear bit 7
         cmpa  #$20       <32?
         bhs   printabl   yes, print as is
notascii lda   #'.        Non-ascii char
printabl sta   ,y+        put in buff
         decb             done?
         bne   ascichar  
         stx   buffptr    save new buffer pointer
         tst   lastflag   last line?
         beq   addCR      no, bra
         ldb   #$10       max bytes per line
         subb  ,s+        b=bytes to null out
         lda   #$20       space
addspc3  sta   ,y+        put in buffer
         decb            
         bne   addspc3   
         lda   #$f0       last row num
         sta   rownum     -> displays no more rows
         bsr   addCR      display line
resetlst clr   lastflag   reset flag
         leax  erasescr,pcr point to erase to end of screen code
         ldy   #era2chrs  length of string
         lbra  writeout   erase end of screen & return
addCR    lda   #$d        <CR>
         sta   ,y        
         leax  i.o.buff,u
         lbra  wrtlin1    go display this line & return

transfer lda   ,x+        get byte
         beq   trandone   exit if done
         sta   ,y+        move it
         bra   transfer   do more
trandone rts              return

noline   lda   #$f0      
         sta   rownum     signal last row
         bra   resetlst   go erase rest of screen


* Point to next LSN in file

nxtsec   ldd   lsn+1      get 2 lower bytes of lsn
         addd  #1         next lsn
         std   lsn+1      save it
         bne   readsec    d<>0 => carry not needed
         inc   lsn        else add carry to MSB of LSN
readsec  lbra  readloop   go read next sector

* Point to previous LSN unless at LSN 0 now

prevsec  ldd   lsn+1      get lsn
         bne   notfirst   <>0 => not LSN 0
         tst   lsn        LSN 0?
         lbeq  getcmd     yes, exit
notfirst subd  #1         else dec LSN
         std   lsn+1      save it
         cmpd  #$ffff     borrow needed if LSN was $xx0000
         bne   readsec    if not, go read
         dec   lsn        do 'borrow'
         bra   readsec    go read previous sector


* Change LSN sub

changLSN lbsr  movecmd   
         leax  sect,pcr   display message
         lbsr  pstring   
         ldy   #7         max # chars to read
         bsr   MakeHex    read & convert them
         bcs   BadLSN    
         ldd   HexBuff+2  get new LSN from buffer
         std   lsn+1     
         lda   HexBuff+1 
         sta   lsn       
         lbra  readloop   go read/display new LSN

BadLSN   lbsr  beep      
         bra   changLSN  

MakeHex  pshs  y          save # bytes to read
         clr   echobyte  
         com   echobyte   echo on
         lbsr  echo       set echo
         puls  y         
         leax  i.o.buff,u point to buffer
         lbsr  readlin    read chars from keyboard
         clr   echobyte  
         lbsr  echo       echo off
         leay  -1,y       strip off CR
         beq   ExitHex    exit if no chars input
         tfr   y,d        # of bytes read -> B
CheckHex lda   ,x+        get char
         bsr   hexdigit   see if it's valid char
         bcs   invalid    if not, beep & redo
         decb             done?
         bne   CheckHex  
         sty   HexBuff    save counter for now
getascii lda   #'0        leading zero, if needed
         ldb   ,-x        get a char
         leay  -1,y       last one?
         beq   cnvrt2     yes, bra
         lda   ,-x        else, get next char in A
         leay  -1,y       dec counter
cnvrt2   bsr   asciihex   convert ascii chars in A/B to hex byte
         pshs  b          save hex byte
         cmpy  #0         all done?
         bne   getascii   no, do more
         ldb   HexBuff+1  else, get # ascii chars 1st read
         incb             get ready for divide
         lsrb             divide by 2 -># of HEX bytes
         clra             leading 0
         leax  HexBuff,u  point to storage
         cmpb  #4         4 hex bytes on stack?
         beq   hexstack   yes, no leading zeroes needed
         sta   ,x+        else, put in leading 0
         cmpb  #3         3 hex bytes on stack?
         beq   hexstack   yes, no more 0's needed
         sta   ,x+        else, put in 0
         cmpb  #2         2 hex bytes?
         beq   hexstack   yes, bra
         sta   ,x+        else, put in another 0
hexstack puls  a          get a hex byte off stack
         sta   ,x+        and put in templsn
         decb             done?
         bne   hexstack   no, bra
         clrb             clear carry bit
         rts             

invalid  lbsr  beep      
coma     set   carry      bit
rts                      

ExitHex  leas  2,s        strip off return address
         lbra  getcmd     exit

hexdigit cmpa  #'0        char <0?
         blo   nothex     yes, bra
         cmpa  #'9        char <9 (digit)?
         bls   ishex      yes, bra
         anda  #$5f       lower->UPPER case
         cmpa  #'F        char >F?
         bhi   nothex     yes, bra
         cmpa  #'A        char <A?
         blo   nothex     yes, bra
ishex    clra             clear carry bit if char is hex
         rts             
nothex   coma             set carry bit if not hex char
         rts             

asciihex bsr   hexnib     convert B to LSNibble
         pshs  b          save LSNib
         tfr   a,b        get ready for MSN
         bsr   hexnib     convert it
         aslb             shift LSNib to MSN
         aslb            
         aslb            
         aslb            
         orb   ,s+        add in LSNib from stack
         rts             

hexnib   subb  #$30       convert asci # to hex
         cmpb  #$9        <=9?
         bls   nowhex     yes, bra
         andb  #$5f       lower->UPPER case
         subb  #7         else sub 7 or $A$F
nowhex   rts             

* Zap sector sub

zap                      
         clr   echobyte  
         com   echobyte   echo on
         lbsr  echo       set echo
         lbsr  movecmd   
         lbsr  clrline    clear line
         leax  zaprompt,pcr point to 'Zap '
         lbsr  pstring    print it
         tst   hexascii   ascii mode?
         bne   zapascii   yes, bra
         leax  byte,pcr   point to 'byte: '
         lbsr  pstring    print it
         ldy   #3         2 chars + CR
         bsr   zapread    read in chars
         bsr   hexobjct   convert to object
         bcs   exitzap    exit if invalid chars
zapstart leax  inbuff,u   point to data buffer
         stx   buffptr    new pointer
         clrb             counter
zapbuff  sta   ,x+        do zap
         decb             done?
         bne   zapbuff    no, loop
         clr   echobyte   echo off
         lbsr  echo       set echo
         inc   wrtflag    signal for auto-write if expert mode
         lbra  disploop   display zapped buffer

zapread  clra             stdin
         leax  i.o.buff,u point to buffer
         os9   i$readln   read in line
         bcs   cheksig1   check for break key if error
         rts              else return
cheksig1 cmpb  #2         break key signal?
         lbne  error      no, process error
         com   hexascii   yes, toggle hex/ascii flag
         leas  2,s        pull return addr off stack
         bra   zap        redo routine

exitzap  clr   echobyte   echo off
         lbsr  echo      
         lbra  getcmd     get new command

zapascii leax  char,pcr   point to 'char: '
         lbsr  pstring    print it
         ldy   #2         1 char + CR
         bsr   zapread    read in char
         lda   ,x         get char
         cmpa  #$20       valid ascii char?
         blo   exitzap    no, exit
         bra   zapstart   go do zap

* Convert 2 hex chars in buffer (X) to object byte

hexobjct bsr   cnvrtnib   convert 1st nibble
         bcs   badrts     exit if bad char
         tfr   a,b        save 1st byte (MS nibble)
         bsr   cnvrtnib   convert 2nd nibble
         bcs   badrts     exit if bad char
         aslb             shift LS nib to MS nib
         aslb            
         aslb            
         aslb            
         pshs  b          save
         ora   ,s+        add MS nib to LS nib
         bra   goodhex    exit

cnvrtnib bsr   isithex    is it valid char?
         bcs   badrts     no, exit
         bra   cnvrthex   yes, convert it to object

isithex  lda   ,x+       
         cmpa  #'0        <0?
         blo   badhex     yes, bra
         cmpa  #'9        <9?
         bls   goodhex    yes, bra
         anda  #$5F       lower->UPPER case
         cmpa  #'A        <A?
         blo   badhex     yes, bra
         cmpa  #'F        >F?
         bhi   badhex     yes, bra
goodhex  andcc  #$FE       clear carry bit if valid
         rts             
badhex   orcc  #1         set carry bit if invalid
badrts   rts             

cnvrthex suba  #$30       convert char to object
         cmpa  #9         decimal digit?
         bls   nowobjct   yes, done
         suba  #7         else, A-F
nowobjct bra   goodhex    clear carry & return

* Write current sector back to disk

writesec tst   xprtflag   expert mode on?
         lbne  getcmd     yes, exit
         bsr   rusure     Sure?
         lbne  getcmd     no, exit
         lbsr  movecmd   
         lbsr  clrline    clear line
         lbsr  movecmd   
         leax  writing,pcr point to message
         lbsr  pstring    display it
xprtwrt  lbsr  lsnseek    seek to start of sector
         lda   inpath     get path #
         lbsr  write100   write out sector
         tst   xprtflag   doing auto-write
         beq   opendone   no, go to getcmd
         clr   wrtflag    signal no more auto-write
         rts              else & return to caller

* Ask 'Are you sure?' and get response

rusure   lbsr  movecmd   
rusure10                 
         clr   echobyte  
         com   echobyte   echo on
         lbsr  echo       set echo
         leax  sure,pcr   point to 'Sure? '
         lbsr  pstring    print it
         lbsr  clrline    blank rest of line
         leax  i.o.buff,u input buffer
         lbsr  read1      read answer
         clr   echobyte   echo off
         lbsr  echo       set echo
         lda   ,x         get response
         anda  #$5f       lower->UPPER case
         cmpa  #'Y        set flags
         rts             

* Open output file sub

openout  tst   outpath    is a file open already?
         bne   opendone   yes, exit
         clr   echobyte  
         com   echobyte   echo on
         lbsr  echo       set echo
         lbsr  movecmd    position cursor
         leax  out$,pcr   point to prompt
         lbsr  pstring    print it
         lbsr  clrline    clear rest of line
         leax  i.o.buff,u point to input buffer
         ldy   #30        29 chars + CR
         lbsr  readlin    read in a line (pathlist)
         clr   echobyte   echo off
         lbsr  echo       set echo

***********************************************
* Return to command prompt if no filename given
* Added 01/09/90 (RAK)
*
         cmpy  #1         <enter> only pressed?
         beq   opendone   yes, abort
*
********************************** END modification

         pshs  x          save pointer to pathlist
         leay  outfile,u  point to storage area
savname  lda   ,x+        get a char from name
         sta   ,y+        save it
         cmpa  #$20       space or CR?
         bhi   savname   
         lda   #$0d       CR
         sta   -1,y       delimit filename
         puls  x          restore pointer to name
         lda   #write.    Access mode = Write
         ldb   #%00001011 attr ----R-wr
         os9   I$Create   create & open file
         bcs   error      exit if error
         sta   outpath    save output path #
         bsr   prntout   
opendone lbra  getcmd     exit

* move cursor & print 'Output pathlist'

prntout  ldd   #outpos   
         lbsr  movecurs  
         leax  out$,pcr   point to 'OUTFILE:'
         lbsr  pstring    print it
         leax  outfile,u  point to name
         lbra  wrtlin1    write name & return


* Write out a sector

write100 leax  inbuff,u   point to data
         ldy   seclen     # chars in sector
         os9   i$write    write sector
         bcs   error     
         rts             

* Close output file sub

closeout lda   outpath    get output path #
         beq   opendone   exit if none open
         os9   i$close    close it
         bcs   error     
         ldd   #outpos   
         lbsr  movecurs  
         lbsr  clrline   
         clr   outpath    flag no output file open
closed   bra   opendone   exit

* Append sector to output file sub

append   lda   outpath    get output path #
         beq   closed     exit if no file open
         bsr   write100   write sector out
         lbra  nxtsec     read in next sector & display it


* ERROR handling routine

error    pshs  b          save error code

* modification by BRI
         clr   <SgnlCode  clear intercept routine signal code
* end modification

         ldd   oldlsn     MSBs of last LSN read
         std   lsn        make it current LSN
         lda   oldlsn+2   LSB of last LSN
         sta   lsn+2      move it
         puls  b          error code
         lds   Ssave      restore Stack pointer
         cmpb  #2         break?
         beq   endexit    yes, don't worry
         cmpb  #3         shift break?
         bne   eofchk     no check if EOF
         clr   wrtflag    cancel auto-write
         bra   endexit   
eofchk   cmpb  #e$eof     EOF error?
         bne   true.err   exit
endexit  lbra  exitzap   
true.err cmpb  #e$bmid    bad module ID error?
         bne   othererr   no, bra
* If module is linked, BMID error must come from trying to Verify modules
* use standard error reporting routine. Otherwise BMID error occurs when
* trying to link (or list names of) modules; need to clear screen after these.
         tst   infile     module linked?
         bne   othererr   yes, use std error routine
         bsr   prterr     else display error #
         leax  cls,pcr   
         ldy   #clschrs  
         lbsr  writeout   clear screen
         lbra  disploop   & redisplay sector
othererr pshs  b          save error code
         lbsr  movecmd    position cursor
         lbsr  clrline   
         puls  b          pull error code
         bsr   prterr     print error # on cmd line
         lbra  getcmd    

* Display error #

prterr   lda   #2         error out path
         os9   f$perr     print error #
         clr   echobyte   echo off
         lbsr  echo      

         leax  i.o.buff,u point to input buffer
         lbra  read1      wait for keypress & return

* Exit with usage prompt if no pathname called

badcall                  
         lda   #2         errout
         leax  hints,pcr 
         ldy   #bufsiz   
         lbsr  wrtlin2   
         ldb   #e$bpnam   set bad path error
         bra   bye       

* Exit to OS9

quit     lda   oldecho    get original echo status
         sta   echobyte   reset echo
         lbsr  echo       to original status
         clrb             no error
bye      os9   f$exit     exit program

* Edit sector sub

edit     lbsr  movecmd   
         leax  edprompt,pcr point to prompt
         lbsr  pstring   
topleft  leax  inbuff,u   point to data buffer
         stx   edbufptr   save pointer
         lda   #1         init position counter
         sta   edpos     
         lda   #$23       top row code
         sta   rownum     save
         lda   #$25       1st hex dump col #
         sta   hexcol     save
         lda   #$58       1st ascii dump col
         sta   asciicol  

revbyte  lbsr  revdisp    set reverse video
         bsr   eddisply   display byte

         ifne  xyflipr   
edinput  lda   rownum     A=row
         ldb   hexcol     B=col
         else            

edinput  lda   hexcol     A=col
         ldb   rownum     B=row
         endc            

         tst   hexascii   Hex mode?
         beq   hexin      yes, bra

         ifne  xyflipr   
         ldb   asciicol   else B= ASCII col
         else            

         lda   asciicol   A= ASCII col
         endc            

hexin    lbsr  movecurs   position cursor
         leax  i.o.buff,u
         tst   hexascii   ascii mode?
         lbne  inputchr   yes, bra

* modification by BRI
* bra inputbyt
         lbra  inputbyt  
* end modification

* Sub to do Hex and ASCII dump for byte to be editted

         ifne  xyflipr   
eddisply lda   rownum     A=row
         ldb   hexcol     b= hex column
         else            

eddisply lda   hexcol     A=Hex column
         ldb   rownum     B=row
         endc            

         lbsr  movecurs   position cursor
         leay  i.o.buff,u point to output buff
         lda   [edbufptr,u] get byte
         pshs  a          save it
         lbsr  convert1   convert to hex, put in buff
         leax  -2,y       reset pointer to hex chars
         ldy   #2         2chars
         lda   #1         stdout
         lbsr  wrtlin2    display chars

         ifne  xyflipr   
         lda   rownum     same row
         ldb   asciicol   get ascii dump col #
         else            

         lda   asciicol   ascii dump col #
         ldb   rownum     same row
         endc            

         lbsr  movecurs   position cursor
         puls  a          get byte again
         anda  #$7F       clear bit 7 for ascii dump
         cmpa  #$20       printable?

         bhs   prntabl1   yes, bra
         lda   #'.        else print as '.'
prntabl1 leax  i.o.buff,u ouput buffer
         sta   ,x         put char in buff
         ldy   #1         1 char
         lbra  writeout   display char & return

* Read in a character; check for BREAK key

* modification by BRI
* toggles cursor on/off if enabled, checks for character
*readit ldy #1 1 char
readit   pshs  b,x        save previous char, input buffer pointer
CFlsh01  clra             std. input
         ldb   #SS.Ready 
         os9   I$GetStt  
         bcc   CFExit     character ready, go get it
         cmpb  #E$NotRdy  no character ready?
         bne   CrsrErr    no, go check other errors
         ldx   #$0001     give up remainder of tick
         os9   F$Sleep   
         bcs   CrsrErr    go clean up & check error
         dec   <CrsrCnt   decrement cursor toggle counter
         lda   <CrsrCnt   get new counter value
         eora  <CrsrFlg   cursor toggle required?
         anda  #%01000000 clear all but active counter bit
         beq   SigChk     no, go check for signal
         com   <CrsrFlg   toggle cursor on or off?
         beq   CrsrOff    go toggle cursor off
         bsr   CrsrOn     go toggle cursor on
         bra   SigChk     go check intercept routine signal code
CrsrOff  leax  CursrOff,pc point [X] to cursor off string
         ldy   #CursOff   number of bytes in string
         bsr   WritCrsr   go write cursor off string
SigChk   ldb   <SgnlCode  get intercept routine signal code
         cmpb  #S$Abort   keyboard abort signal? (error #2)
         beq   CrsrErr    yes, go report it
         cmpb  #S$Intrpt  keyboard interrupt signal? (error #3)
         bne   CFlsh01    no, go check for data again
CrsrErr  stb   ,s         save error code for sigchek2
         bsr   CrsrOn     go make sure cursor is on
         puls  b,x        recover error code, input buffer pointer
         bra   cheksig2  
CrsrOn   leax  CursrOn,pc point [X] to cursor on string
         ldy   #CursOn    number of bytes in string
WritCrsr lda   #1         std. output
         os9   I$Write   
         clrb             ignore any/all errors
         rts             
CFExit   bsr   CrsrOn     go make sure cursor is on
         puls  b,x        recover previous char, input buffer pointer
         ldy   #1         1 char
* end modification

         clra             stdin
         os9   i$read     read in char
         bcs   cheksig2   chek for BREAK if error
         rts              else return

* modification by BRI
* clears old signal, traps BREAK,
* cleans up before reporting other errors
* (fixes shift-BREAK/control-BREAK in edit mode and
* error report stack clean up bugs)
* cheksig2 cmpb #2 BREAK key signal?
* lbne error no, process error
* com hexascii yes, toggle hex/ascii flag
* leas 2,s pull return addr off stack
* bra edinput loop back
cheksig2 leas  2,s        dump return address
         clr   <SgnlCode  clear old signal
         cmpb  #2         keyboard abort? (BREAK)
         beq   TrapSgnl   yes, trap it & toggle hex/ascii
         pshs  b          save error code
         lbsr  reset      reset reversed chars
         clr   <rownum    reset row #
         puls  b          recover error code
         lbra  error      go process error
TrapSgnl com   <hexascii  yes, toggle hex/ascii flag
         lbra  edinput    loop back
* end modification


* Input a hex byte

inputbyt bsr   readit     read in a char
         bsr   digit      is it valid hex digit?
         bcs   edcurs     no, see if it's arrow key
         lbsr  writeout   yes, display char
         ldb   ,x         save char

* modification by BRI
* bsr readit read another char
         lbsr  readit     read another char
* end modification

         bsr   digit      is it valid?
         bcs   edcurs     no, check for arrows
         exg   a,b        A= 1st char
         lbsr  asciihex   change 2 ascii chars to hex byte
         stb   [edbufptr,u] put new byte in buffer
         lda   #1        
         sta   wrtflag    signal auto-write
         bra   movert     move to next byte

* Check to see if char is valid hex digit.
* Exit with Carry set if not valid.

digit    lda   ,x         get char from buffer
         cmpa  #'0        < 0?
         blo   notdig     YES, set carry
         cmpa  #'9        Between 0 & 9?
         bls   gotnib     Yes, return
         anda  #$5F       Lowercase -> Upper
         cmpa  #'F        > F?
         bhi   notdig     Yes, set carry
         cmpa  #'A        Between A & F?
         blo   notdig     No, set carry
gotnib   andcc  #$fe       clear carry bit
         rts             
notdig   orcc  #1         set carry bit
         rts             

* Input single ASCII character

* modification by BRI
*inputchr bsr readit read char
inputchr lbsr  readit     read char
* end modification

         lda   ,x         get char
         cmpa  #$20       valid ascii char?
         blo   edcurs     no, check for arrows
         sta   [edbufptr,u] yes, put in buffer
         lda   #1        
         sta   wrtflag    signal auto-write
         bra   movert     go do next byte

* Check if char is arrow (for cursor moves)

edcurs   cmpa  #9         Right arrow?
         beq   movert    
         cmpa  #8         Left arrow?
         beq   movelt    
         cmpa  #$c        Up arrow?
         lbeq  moveup    
         cmpa  #$a        Down arrow?
         lbeq  movedn    
         cmpa  #$d        CR?
         lbne  edinput    no, get another key

* Exit edit routine
         lbsr  reset      reset reversed chars
         clr   rownum     reset row #
         lbra  getcmd     return to command level

* Move to next byte on screen

movert   lbsr  reset      reset display byte
         tst   seclen+1   editting partial (last) sec?
         beq   rtptr      no, bra
         lda   edpos      position # in sector
         cmpa  seclen+1   last byte?
         lbeq  topleft    yes, bra
rtptr    ldd   edbufptr   get pointer
         addd  #1         set to next byte
         std   edbufptr   save
         inc   edpos     

displyrt inc   asciicol   inc display counter
         lda   asciicol   get counter
         cmpa  #$68       at end of screen row?
         bhs   rowdn      yes, move down a row
         lda   hexcol     no, inc hex display counter
         adda  #3         3 screen columns per byte
         sta   hexcol     save
         lbra  revbyte    go do next byte
rowdn    inc   rownum     next row
         lda   rownum     get row #
         cmpa  #$32       past bottom row?
         lbhi  topleft    yes, go to top row
         lda   #$25       1st hex column #
         sta   hexcol     reset counter
         lda   #$58       1st ascii col #
         sta   asciicol   reset counter
         lbra  revbyte    go do display

* Move to previous byte on screen

movelt   bsr   reset      reset displayed byte
         ldd   edbufptr   get data pointer
         subd  #1         dec it
         std   edbufptr  
         dec   edpos      & position counter
         dec   asciicol   dec display counter
         lda   asciicol   get col #
         cmpa  #$58       past left end of row?
         blo   rowup      yes, move up a row
         lda   hexcol     get hex col #
         suba  #3         move left 3 columns
         sta   hexcol     save
         lbra  revbyte   
rowup    dec   rownum     move up a row
         lda   #$52       col # of right end of hex dump
         sta   hexcol     save
         lda   #$67       col # of right end of ascii dump
         sta   asciicol   save
         lda   rownum     get row #
         cmpa  #$23       past top row?
         blo   gobot      yes, go to bottom row
         lbra  revbyte    no, display next byte
gobot    ldx   edbufptr   old pointer
         ldb   seclen+1   partial (last) sec?
         beq   botptr     no, bra
         stb   edpos      new last position
         clra            
         leax  d,x        new pointer with partial sector
         decb             offset to byte in buffer
         pshs  b         
* MSN of B is last row-1 with partial sector
         lsrb            
         lsrb            
         lsrb            
         lsrb             Now B is last row-1
         addb  #$23      
         stb   rownum    
         lda   ,s+        offset
         anda  #$0f       A=last col
         pshs  a         
         adda  #$58       left most ASCII column
         sta   asciicol   new ASCII col
         puls  a         
         ldb   #3         3 columns per hex byte
         mul             
         addb  #$25       1st hex col
         stb   hexcol    
         bra   savebot   
botptr   lda   #$32       bottom row #
         sta   rownum     save
         leax  $100,x     new pointer
savebot  stx   edbufptr   save new pointer
         lbra  revbyte    do next byte

* Reset byte displayed in reverse video to normal video

reset    lbsr  normdisp   set normal video
         lbra  eddisply   go display byte

* Move up a row on screen

moveup   bsr   reset      reset reversed byte
         ldb   seclen+1   partial sector?
         beq   moveup1    no, bra
         lda   rownum    
         cmpa  #$23       at top row now?
         beq   moveup2    yes, bra
moveup1  ldd   edbufptr   get data pointer
         subd  #$10       move back 16 bytes
         std   edbufptr   save new pointer
         ldb   edpos     
         subb  #$10       dec position counter by $10
         stb   edpos     
         dec   rownum     move up a row
         lda   rownum     get new row #
         cmpa  #$23       above top row
         bhs   updone     no, go display next byte
         lda   #$32       set to bottom row
         sta   rownum    
         ldd   edbufptr   get data pointer
         addd  #$100      point to new byte
         std   edbufptr   and save
updone   lbra  revbyte    display next byte

moveup2  andb  #$f0       MSN=row offset
         lda   seclen+1   bytes read
         anda  #$0f       last col in last row
         cmpa  edpos      to left of current position?
         bhs   moveup3    yes, bra
         subb  #$10       else correct row offset
moveup3  clra            
         pshs  b,a       
         ldd   edbufptr  
         addd  ,s+        add offset
         std   edbufptr  
         ldb   edpos     
         addb  ,s        
         stb   edpos      new position
         puls  b         
         lsrb            
         lsrb            
         lsrb            
         lsrb             row offset in LSNib
         addb  #$23       calc new rownum
         stb   rownum    
         bra   updone    

* Move down a row on screen

movedn   bsr   reset      reset reversed byte
         ldb   seclen+1   partial sector?
         beq   movedn1   
         subb  edpos     
         cmpb  #$10      
         blo   movedn2   
movedn1  ldd   edbufptr   get data pointer
         addd  #$10       point 16 bytes ahead
         std   edbufptr   and save
         lda   edpos     
         adda  #$10      
         sta   edpos     
         inc   rownum     move down a row
         lda   rownum     check to see if below
         cmpa  #$32       bottom row?
         lbls  revbyte    no, display next byte
         ldd   edbufptr   get data pointer
         subd  #$100      reset to new byte
         std   edbufptr   save
topptr   lda   #$23       yes, set for top row
         sta   rownum     save
         lbra  revbyte    display next byte

movedn2  clra            
         ldb   edpos     
         decb            
         andb  #$f0       B = offset to first row
         pshs  b,a       
         ldd   edbufptr  
         subd  ,s+        reset pointer
         std   edbufptr  
         ldb   edpos     
         subb  ,s+        reset position counter
         stb   edpos     
         bra   topptr    


* Start new SHELL

goshell  lda   oldecho    get original echo status
         sta   echobyte   set up for change
         bsr   echo       set echo
         leax  shell$,pcr point to 'SHELL' text
         ldy   #$10       # pages in new param area
         leau  i.o.buff,u new param area
         lda   #$0d       CR to
         sta   ,u         init param area
         ldd   #$0000     language/type
         os9   f$fork     fork to new shell
         lbcs  error     
         os9   f$wait     wait for shell to die
         ldu   usave      pull data pointer
         leax  inbuff,u  
         stx   buffptr    reset buffer pointer
         clr   echobyte   echo off
         bsr   echo       set echo
redo     lbsr  clrscr     clear screen
         lbra  disploop   redo display

* Read in option section (32 bytes) of stdin path descriptor & turn echo on/off

echo     pshs  x          save
         leas  -32,s      make room for data
         leax  ,s         point to buffer
         clra             path = 0
         clrb             SS.OPT
         os9   i$getstt   read in 32 bytes
         lbcs  error     
         lda   echobyte   new echo status byte
         sta   4,x        set echo
         clra             path =0
         os9   i$setstt   set new status
         lbcs  error     
         leas  32,s       reset stack
         puls  x,pc       pull x & return

* Verify CRC on file, if it's a valid module.

verify   lbsr  movecmd    position cursor
         leax  vrfymess,pcr display message
         lbsr  pstring   
         ldu   #$0000    
         ldx   #$0000    
         stx   fileln     init file length
         lda   inpath     path #
         os9   i$seek     rewind to LSN 0
         lbcs  error     
         ldu   Usave      restore U
initCRC  ldd   #$FFFF     initialize CRC bytes
         std   crc       
         stb   crc+2     
         leax  i.o.buff,u input buffer
         ldy   #8         8 bytes to read
         lda   inpath     path #
         os9   i$read     read in 8 header bytes
         lbcs  error      exit on error
         cmpy  #8         all read in ok?
         lbne  verr       no, error
         ldd   ,x         get 1st 2 bytes read in
         cmpa  #$87       module sync byte?
         lbne  verr       no, error
         cmpb  #$CD       module sync byte?
         lbne  verr       no, error
         ldd   2,x        get module length
         cmpd  #$f        minimum module length
         lbls  verr       exit if less
         subd  #3         omit old CRC bytes
         std   vmodlen    module length less CRC
         addd  fileln     update file length
         std   fileln     read so far

* Check header parity by EOR'ing 1st 8 bytes to themselves, then taking
* the one's complement. This is the 9th header byte, the parity check.

         clra             prepare for EORs
         ldb   #8         # header bytes to EOR
hedpar   eora  ,x+        EOR bytes read in
         decb             done?
         bne   hedpar     no, bra
         coma             A now is header parity
         sta   ,x         put in buffer
         ldy   #1         1 char to write
         lda   inpath     path #
         os9   i$write    write parity byte out
         lbcs  error     
         ldd   vmodlen    get # byte in module
         subd  #9         9 bytes already read
         std   vmodlen    save
         leax  i.o.buff,u start of header bytes
         ldy   #9        
         bsr   CRCcal     calculate CRC on 1st 9 bytes
bytsleft lda   inpath     path #
         ldy   #bufsiz    # chars to read
         cmpy  vmodlen    buffer <= # bytes left to read?
         bls   readmod    yes, bra
         ldy   vmodlen    else, get exact # chars left to read
readmod  os9   i$read     read in Y chars
         bcs   verr       exit on error
         sty   bytsread   save # bytes read in
         bsr   CRCcal     calc CRC on bytes just read in
         ldd   vmodlen    # bytes
         subd  bytsread   minus # bytes just read in
         std   vmodlen    save # byte left
         bne   bytsleft   do more if some left
* Compare current position in file with # of bytes in module header
* to prevent overwriting next module, in case module length changed.
         lda   inpath     path number
         ldb   #ss.pos    file position code
         os9   i$getstt   get position in file
         tfr   u,d        D = position
         ldu   Usave      restore U
         cmpd  fileln     same as bytes read so far?
         bne   verr       no, exit
         com   crc        do one's
         com   crc+1      complement on
         com   crc+2      CRC accumulator
         leax  crc,u      point to accumulator
         ldy   #3         3 bytes to write
         lda   inpath     path #
         os9   i$write    write out 3 CRC bytes
         lbcs  error     
         ldd   #3         update # bytes read/written
         addd  fileln    
         std   fileln    
         ldb   #ss.eof    test for EOF
         lda   inpath    
         os9   i$getstt  
         lbcc  initCRC    bra if not EOF
         cmpb  #e$eof     EOF?
         lbne  error      no, exit
* Redisplay LSN (may have changed with verify)
         lbsr  seeksec    read in sector again
         lbra  disploop   redo display

* Calculate CRC sub. Enter with Y = # of bytes to calculate CRC over.
*                               X = address of 1st byte

CRCcal   leau  crc,u      point to CRC bytes
         os9   f$crc      calc CRC
         lbcs  error     
         ldu   Usave      restore U
         rts             

* Verify error display sub

verr     ldd   #cmdpos    position cursor
         lbsr  movecurs   at cmd position
         leax  verrmess,pcr point to message
         lbsr  pstring    display it
         ldb   #e$bmid    bad module ID
         lbsr  prterr     display error #
         lbra  getcmd     exit

* 'Link' to a given module or display all modules if no name is input

linker   tst   infile     linked already?
         lbne  getcmd     yes, exit
         ldd   #0        
         std   fileln     init vars
         std   lmodlen    "
         clr   echobyte  
         com   echobyte  
         lbsr  echo       echo on
         lbsr  movecmd   
         lbsr  clrline   
         leax  linkmess,pcr prompt
         lbsr  pstring    print it
         leax  infile,u   point to buffer for module name
         ldy   #30        max name length+1
         lbsr  readlin    read in module name
         clr   echobyte  
         lbsr  echo       echo off
         cmpy  #1         any name entered?
         lbne  parsmod    yes, go find it
* else list all module names
         clr   infile     flag => no modules linked
         leax  linkhdr,pcr point to header
         lbsr  wrtlin1    write it
nxtmod   ldd   lmodlen    current mod length
         addd  fileln     + cummulative lengths
         std   fileln     save
         tfr   d,u        point u to next module
         ldx   #0        
         lda   inpath    
         os9   i$seek    
         bcs   moderr    
         ldu   Usave      restore U
         leax  i.o.buff,u
         ldy   #6         bytes to read
         os9   i$read    
         bcs   moderr    
         ldd   ,x++       get sync bytes
         cmpa  #$87       OK?
         bne   moderr1    no, exit
         cmpb  #$CD       OK?
         bne   moderr1    no, exit
         leay  i.o.buff,u
         ldd   ,x++       get module length
         std   lmodlen    save
         ldd   ,x++       offset to module name
         pshs  d          save
         ldd   fileln     current offset
         bsr   convert2   convert D to ASCII
         lda   #$20       space
         sta   ,y+        put in buffer
         ldd   lmodlen    current module length
         bsr   convert2   convert to ASCII
         lda   #$20      
         sta   ,y+        insert space
         ldd   fileln     offset to mod start
         addd  ,s++       add mod name offset
         tfr   d,u        U = offset to name
         ldx   #0        
         lda   inpath    
         os9   i$seek     seek to module name
         lbcs  error     
         ldu   Usave      restore U
         tfr   y,x        point x to buffer
         ldy   #29        max chars in name
         lda   inpath    
         os9   i$read    
         lbcs  error     
namend   lda   ,x+        find char w/ bit 7 set
         bpl   namend    
         anda  #$7f       clear bit 7
         sta   -1,x      
         lda   #$0d       CR
         sta   ,x         end output line
         leax  i.o.buff,u buffer start
         lbsr  wrtlin1   
         bra   nxtmod    

convert2 lbsr  convert1   put ASCII val of A in Y
         tfr   b,a        repeat for B
         lbra  convert1   and return

moderr2  cmpb  #e$eof    
         bne   moderr    
         ldb   #e$MNF     module not found error
         bra   moderr    
moderr1  ldb   #E$BMID    bad module ID error
moderr   clr   infile     flag => not linked
         cmpb  #e$eof     end of file?
         lbne  error      no, print error
         lbsr  read1      wait for keypress
         leax  inbuff,u  
         stx   buffptr    reset buffer pointer for display
         lbra  redo       redo display

parsmod  os9   f$prsnam  
         lbcs  error     
         stb   modnmlen   save length of name
         decb             name len -1
         lda   b,x        last char of name
         ora   #$80       set bit 7
         sta   b,x       
         stx   CRC        save pointer
         ldu   #0        
modloop  ldx   #0        
         lda   inpath    
         os9   i$seek     go to start of file
         lbcs  error     
         ldu   Usave      restore U
         leax  i.o.buff,u buffer
         ldy   #6         bytes to read in
         os9   i$read    
         bcs   moderr2   
         ldd   ,x++       sync bytes
         cmpa  #$87       OK?
         bne   moderr1   
         cmpb  #$CD       OK?
         bne   moderr1   
         ldd   ,x++       module length
         std   lmodlen    save
         ldd   ,x         mod name offset
         addd  fileln     d=true offset to name
         tfr   d,u       
         ldx   #0        
         lda   inpath    
         os9   i$seek     seek to mod name
         bcs   moderr2   
         ldu   Usave      restore U
         leax  i.o.buff,u buffer
         ldy   #29        max chars in name
         os9   i$read     read in name
         bcs   moderr2   
         tfr   x,y       
         ldx   CRC        point to desired name
         ldb   modnmlen   get len of name
         os9   f$cmpnam   do they match?
         bcc   newbase    yes, bra
         ldd   lmodlen    no, check next
         addd  fileln     new offset
         std   fileln    
         tfr   d,u       
         bra   modloop   

* Set Offset to module. LSN is functionally set to 0.

newbase  lda   #$0d       CR
         sta   b,x        delimit name
         decb            
         lda   b,x        last char
         anda  #$7f       clr bit 7
         sta   b,x       
         ldd   fileln     get offset
         std   offset    
         ldd   #0006     
         leax  LSN,u     
nbloop   sta   ,x+       
         decb            
         bne   nbloop    
         lbra  readloop   go read 1st 'LSN'

* Display module name and offset

prntmod  ldd   #modpos   
         lbsr  movecurs   point to screen position
         leax  modnmhdr,pcr mod name header
         lbsr  pstring    print it
         leax  infile,u   point to name
         lbsr  wrtlin1    print it
         ldd   #offpos    'offset' screen postion
         lbsr  movecurs  
         leax  offmess,pcr
         lbsr  pstring    print 'Offset' label
         leay  i.o.buff,u
         ldd   offset    
         lbsr  convert2   convert offset to ASCII
         lda   #$0d      
         sta   ,y         delimit offset
         lbra  writeout   display it & return

* 'Unlink' named module and restore LSN to original file's LSN

unlinker tst   infile     linked?
         lbeq  getcmd     no, exit
         ldd   #0008     
         leax  LSN,u     
unloop   sta   ,x+       
         decb            
         bne   unloop    
         ldd   #modpos    position cursor
         lbsr  movecurs  
         lbsr  clrline    erase module name
         lbsr  clrline    erase offset
         clr   infile     flag => no modules linked
         lbra  readloop  

* Toggle expert mode - edits and zaps of buffer are automatically written

expert   tst   xprtflag   in expert mode now?
         beq   xprton     no, go turn it on
         clr   xprtflag   signal mode off
         ldd   #xprtpos  
         lbsr  movecurs  
         lbsr  clrline    erase label
xprtout  lbra  getcmd    
xprton   lbsr  rusure     Sure?
         bne   xprtout    no, exit
         com   xprtflag   signal xpert mode
         ldd   #xprtpos  
         lbsr  movecurs   position cursor
         leax  xprtmess,pcr
         lbsr  pstring    display 'EXPERT'
         bra   xprtout   

help     lbsr  clrscr     clear screen
         leax  helper,pcr point to help message
         ldy   #helpchrs  length of message
         lbsr  wrtlin2    print it
         leax  i.o.buff,u
         lbsr  Read1      get 1 byte
         lbra  redo       redo display

find                     
         clr   echobyte  
         com   echobyte   echo on
         lbsr  echo      
         lbsr  movecmd   
         lbsr  clrline   
         tst   FHexAsc    Hex or Ascii mode?
         bne   charfind   bra if Ascii
         leax  findbyte,pcr
         lbsr  pstring    display prompt
         ldy   #33        max chars to read + 1
         lbsr  FRead     
         cmpy  #1         blank line entered?
         lbeq  exitfind   yes, exit find mode
         leay  -1,y       get rid of CR
         tfr   y,d       
         lsrb             divide # bytes read by 2
         lbcs  badfind    bra if odd # read
         stb   TargLen    save # bytes in find string
         leau  findstr,u  point to storage area
* Convert 2 bytes pointed to by X to object byte in A
FConvert lbsr  hexobjct  
         lbcs  badfind    bra if invalid char
         sta   ,u+        save byte
         leay  -2,y       all chars converted?
         bne   FConvert   no, bra
         ldu   Usave      restore U
         bra   gofind    

* Input a string of ASCII characters to search for

charfind leax  findchar,pcr
         lbsr  pstring    display prompt
         ldy   #17        max # of chars + 1
         lbsr  FRead     
         cmpy  #1         only CR entered?
         lbeq  exitfind   yes, exit find mode
         tfr   y,d        # bytes read
         decb             dump CR
         stb   TargLen    save length of target string
         leay  findstr,u 
find20   lda   ,x+        move target
         sta   ,y+        string to storage area
         decb             done?
         bne   find20    

* Check if byte from target string matches byte in buffer by EOR'ing the two.
*  If they match exactly, result is 0. If in 'char' search mode, EOR results
*  in bits 5 and/or 7 being set if 2 bytes differ only by case or bit 7 status

gofind                   
*****************************
* Added 01/08/90 (RAK)
*
         clr   echobyte   echo off
         lbsr  echo      
*
* END of modification
*****************************
         leax  inbuff,u   point to sector buffer
find30   ldb   seclen+1   # bytes in this sector
         leay  findstr,u  point to target string
find50   lda   ,y         get 1st target byte
         eora  ,x+        does it match?
         lbeq  found1     yes, bra
         tst   FHexAsc    in 'char' search mode?
         beq   find60     no, bra
         bita  #%01011111 else, only bits 5 &/or 7 set?
         lbeq  found1     bra if so
find60   decb             whole sector checked?
find70   bne   find50     no, bra
* No match in this sector. Read in next sector.

****************************************************
* Modification (addition) by RAK 01/08/90
* Read a character from std in to catch a break
* key which allows aborting a <F>IND.
* Note: "finderr2" resets the stack.
*
         pshs  d,x,y      save registers
         clra             std in
         ldb   #SS.Ready 
         os9   I$GetStt   was there a key press?
         bcs   NoKey      no, skip read
         leax  i.o.buff,u point to buffer
         lbsr  Read1      get a key
         lda   ,x         get the key
         cmpa  #5         break key?
         beq   finderr2   yes, stop <F>ind
NoKey    puls  d,x,y      no, restore registers
*
* End of modification
****************************************************

         bsr   FNxtsec    get next sector
         bra   find30     back to loop

FNxtSec  tst   infile     module linked?
         beq   find75     no, bra
         ldd   lmodlen    else, get module length
         subd  #1         now A = LSN of last sector
         cmpa  LSN+2      was this last sector?
         beq   finderr2   yes, bra
find75   ldd   lsn+1      else, get next sector
         addd  #1         inc lsn
         std   lsn+1     
         bne   find80     bra if no carry needed
         inc   lsn        else, do add in carry
find80   lbsr  lsnseek    seek to next sector
         leax  inbuff,u   point to sector buffer
         stx   buffptr    save
         tst   infile     module linked?
         beq   find256    no, bra
         ldd   lmodlen    linked mod length
         suba  lsn+2      > $100 bytes left?
         bne   find256    yes, bra
         tfr   d,y        else, set up for smaller read
         bra   FRdSome   
find256  ldy   #$100     
FRdSome  lda   inpath    
         os9   i$read    
         bcs   finderr   
         sty   seclen     save # bytes read
         rts             

* Input byte or char string to find

FRead    leax  i.o.buff,u
         clra             stdin
         os9   i$readln  
         bcs   cheksig3  
         rts             

ChekSig3 leas  2,s        scratch return addr
         clr   SgnlCode   clear old signal
         cmpb  #2         BREAK key?
         lbne  error      no, exit
         com   FHexAsc    yes, toggle Hex/Ascii flag
         lbra  find      

badfind  ldu   Usave      restore U
         bsr   beep      
         lbra  find      

* Make a beep
beep     leax  bell,pcr  
         ldy   #1        
         lbra  writeout   beep & return

* If error reading next sector was EOF, then find was unsuccessful.
* Re-read original sector and return to CMD: prompt

finderr  cmpb  #e$eof     EOF?
         lbne  error      no, exit
finderr2 lds   Ssave      dump return addr
         ldd   oldlsn     original LSN
         std   lsn       
         lda   oldlsn+2  
         sta   lsn+2     
         lbsr  seeksec    read original LSN
         sty   seclen     save bytes read
         bsr   beep      

exitfind lbra  exitzap    exit

found1   pshs  b          # bytes left in sector + 1
         decb             # save bytes left if this search unsuccessful
         stb   FBytes     and for 'Next' command
* Save pointer (X) to next byte in buffer for search to resume if this search
*  is unsuccessful or for 'Next' command
         stx   findptr    pointer for next search
         ldb   TargLen    #bytes in target string
find90   decb             whole string checked?
         beq   matched    yes, match found
         dec   ,s         else, more bytes left in sector?
         beq   find130    no, read in next
find100  leay  1,y        else, point to next target byte
         lda   ,y         target byte
         eora  ,x+        match?
         beq   find90     yes, loop back for more
         tst   FhexAsc    in 'char' search mode?
         beq   find110    no, bra
         bita  #%01011111 only bits 5 &/or 7 set?
         beq   find90     yes, bra
find110  leas  1,s        else, dump counter
* Restore buffer pointer (X) to byte after 1st byte found that matched in
*  search just completed (unsuccessfully). Restore B to # bytes left in 
*  sector at that point. Y = start of target string.
         ldx   findptr    ready for new search
find120  leay  findstr,u 
         ldb   FBytes     bytes left in sector
         lbra  find70    

* Read in next sector to complete test for match
find130  leas  1,s        dump counter
         pshs  b,y        save counter & target pointer
         lbsr  FNxtSec    read in next sector
         puls  b,y        restore counter & target pointer
         lda   seclen+1   # bytes in this sector
         pshs  a          save
         bra   find100    continue search

* Successful Find
*   Must determine whether target string starts in last LSN read or
*    next-to-last, for display.

matched  leas  1,s        dump counter
         lda   lsn+2     
         cmpa  oldlsn+2   did we have to read a new sector?
         beq   match40    no, bra
         cmpx  findptr    does target start in last sector read?
         bhs   match30    yes, bra
match10  ldd   lsn+1      else, set to re-read previous LSN
         subd  #1        
         std   lsn+1     
         cmpd  #$ffff    
         bne   match20   
         dec   lsn       
match20  lbsr  seeksec    re-read sector
         sty   seclen     save bytes read ($100)
match30  ldd   lsn        update 'oldlsn'
         std   oldlsn    
         lda   lsn+2     
         sta   oldlsn+2  
match40  lbsr  display    (re)display sector
* Get offset of found string from beginning of LSN
         ldd   findptr    addr 1 byte past start of found string
         subd  #1         D = addr of string
         std   edbufptr   save for display
         subd  buffptr    D (B) = offset from buff start
* Now LS nib of B = col #, MS nib = row # for display
         pshs  b         
         andb  #$0f       mask off MS nibble
         pshs  b         
         addb  #$58       add offset for ascii dump column
         stb   asciicol  
         puls  b         
         lda   #3         3 screen columns per hex byte dump
         mul             
         addb  #$25       add offset for hex dump column
         stb   hexcol    
         puls  b         
         andb  #$f0       mask off LS nibble
         lsrb            
         lsrb            
         lsrb            
         lsrb             B now = row #
         addb  #$23       add offset
         stb   rownum    
         lbsr  revdisp    reverse video
         lbsr  eddisply   display 1st byte in found string
         lbsr  normdisp   normal video
         clr   rownum    
         lbra  exitfind   done *** This line changed from 'lbra getcmd' in Version 2.0 ***

* Locate next occurrence of string located with 'Find' command.
*  Search starts where 'Find' left off, unless LSN has since changed,
*   in which case search starts at start of present LSN

next     tst   TargLen    is there a string to find?
         lbeq  getcmd     no, exit
         lbsr  movecmd   
         leax  srchmess,pcr
         lbsr  pstring    display "Searching"
         ldx   findptr    pointer into buffer where 'find' left off
         lbeq  gofind     0 => begin at start of LSN
         lbra  find120   

* Display file size and input new value

diddle   lbsr  movecmd   
         leax  lenmess,pcr
         lbsr  pstring   
         com   zeroflag   suppress leading zeroes
         leay  i.o.buff,u
         ldd   FileLen    MSB of file length
         lbsr  convert1   convert 1st nibble to ascii
         tfr   b,a       
         lbsr  convert1   do 2nd nibble
         ldd   FileLen+2  LSB of file length
         lbsr  convert1   do 3rd nibble
         clr   zeroflag   stop suppressing leading zeroes
         tfr   b,a       
         lbsr  convert1  
         ldd   #$2020    
         std   ,y++      
         std   ,y++      
         leax  i.o.buff,u
         stx   bytsread   temp storage
         tfr   y,d       
         subd  bytsread   get # chars to display
         tfr   d,y        setup for i$writln
         lbsr  writeout  
         leax  newmess,pcr
         lbsr  pstring    display message
         ldy   #9         max chars to read
         lbsr  MakeHex    convert them to object
         bcs   diddle    
         ldd   #cmd1pos  
         lbsr  movecurs  
         lbsr  rusure10   ask  'Sure?'
         lbne  getcmd    
         ldx   HexBuff    MSB of new file length
         ldu   HexBuff+2  LSB ""
         ldb   #ss.size  
         lda   inpath    
         os9   i$setstt   set new file length
         lbcs  error     
         stx   FileLen   
         stu   FileLen+2 
         ldu   Usave     
* Make sure LSN displayed is still within file (in case file shortened).
*  If not, reset display to show last LSN with new file length.
         lda   FileLen    MSB of file length
         cmpa  lsn        is max LSN > current LSN?
         blo   RstLSN     no, bra
         bne   diddled    else, bra if LSN not last
         ldd   FileLen+1  check LSB's (MSB's equal)
         cmpd  lsn+1     
         bls   RstLSN10  
diddled  lbra  readloop   re-read sector & display

RstLSN   sta   lsn        reset MSB of lsn
         ldd   FileLen+1  get LSB's of last sector
RstLSN10 tst   FileLen+3  need to correct?
         bne   RstLSN20  
         subd  #1        
RstLSN20 std   lsn+1      reset LSB's of lsn
* If D was 0, need to 'borrow'
         cmpd  #$ffff     was D 0?
         bne   diddled    no, bra
         dec   lsn        else, correct LSB of LSN
         bra   diddled   

push     lda   StackCnt   # of LSN's on stack
         cmpa  #MaxStack  more room?
         bhs   full       no, bra
         ldb   #3         3 bytes per entry
         mul             
         leax  Stack,u    start of stack
         leax  b,x        add offset
         ldd   lsn       
         std   ,x++       put current LSN on stack
         lda   lsn+2     
         sta   ,x        
* Now that LSN is on stack, check to make sure it isn't the last one
*  pushed, as well. If so, don't increment StackCnt, which effectively
*  cancels the Push operation.
         tst   StackCnt   any sectors thus far?
         beq   pushOK     no, do push
         cmpa  -3,x       Is LSB of LSN the same as previous LSN pushed?
         bne   pushOK     no, bra
         ldd   lsn        check MS bytes of LSN
         cmpa  -5,x       do they match?
         beq   pushed     yes, exit without completing push
pushOK   inc   StackCnt   complete push
pushed   lbra  getcmd     exit

* Stack is full - display message
full     lbsr  movecmd   
         leax  fullmess,pcr
         lbsr  pstring    display 
         lbsr  read1      wait for keypress
         bra   pushed    

remove   lda   StackCnt   # sectors on stack
         beq   pushed     exit if none
         ldb   #3         3 bytes per entry
         mul              offset to END of entry
         subb  #3         no B = offset to entry
         leax  Stack,u   
         leax  b,x        point to entry
         ldd   ,x++       get MS bytes of LSN
         std   lsn       
         lda   ,x         get LS byte of LSN
         sta   lsn+2      reset LSN
         dec   StackCnt   1 less sector on stack
         lbra  readloop   and go read in new sector

         emod            
dEDend   equ   *         
         end             

            ENDC
