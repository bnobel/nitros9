<chapter>
<title>Characteristics of Compiled Programs</title>

<section>
<title>The Object Code Module</title>
<para>
The compiler produces position-independent, reentrant 6809 code
in a standard OS-9 memory module format. The format of an executable
program module is shown below. Detailed descriptions of each
section of the module are given on following pages.
</para>
<informalfigure>
<screen>
Module
Offset

                 +-------------------------------+
                 !                               !
                 !         Module Header         !
                 !                               !
                 !-------------------------------!
                 !       Execution Offset        !
                 !-------------------------------!
                 !    Permanent Storage Size     !
                 !-------------------------------!
                 !   Data-text Reference Count   !
                 v                               v
                 :  Data-text Reference Offsets  :
                 ^                               ^
</screen>
</informalfigure>
<section>
<title>Module Header</title>
<para>
This is a standard module header with the type/language byte set to
$11 (Program + 6809 Object Code), and the attribute/revision byte
set to $81 (Reentrant + 1).
</para>
</section>

<section>
<title>Execution Offset</title>
<para>
</para>
</section>

<section>
<title>Storage Size</title>
<para>
</para>
</section>

<section>
<title>Module Name</title>
<para>
</para>
</section>

<section>
<title>Information</title>
<para>
</para>
</section>

<section>
<title>Executable Code</title>
<para>
</para>
</section>

<section>
<title>String Literals</title>
<para>
</para>
</section>

<section>
<title>Initializing Data and its Size</title>
<para>
</para>
</section>

<section>
<title>Data References</title>
<para>
</para>
</section>
</section>

<section>
<title>Memory Management</title>
<para>
The C compiler and its support programs have default conditions
such that the average programmer need not be concerned with details
of memory management. However, there are situations where advanced
programmers may wish to tailor the storage allocation of a program
for special situations. The following information explains in
detail how a C program's data area is allocated and used.
</para>

<section>
<title>Typical C Program Memory Map</title>
<para>
</para>
</section>

<section>
<title>Compile Time Memory Allocation</title>
<para>
</para>
<para>
The following rules can serve as a rough guide to estimate how
much memory to specify:
</para>
<orderedlist>
<listitem><para>
The parameter area should be large enough for any anticipated
command line string.
</para></listitem>
<listitem><para>
The stack should not be less than 128 bytes and should take
into account the depth of function calling chains and any
recursion.
</para></listitem>
<listitem><para>
All function arguments and local variables occupy stack space
and each function entered needs 4 bytes more for the return
address and temporary storage of the calling function's register
variable.
</para></listitem>
<listitem><para>
Free memory is requested by the Standard Library I/O
functions for buffers at the rate of 256 bytes per accessed
file. The does not apply to the lower level service request I/O
functions such as "open()", "read()" or "write()" not to
"stderr" which is always un-buffered, but it does apply to both
"stdin" and "stdout" (see the Standard Library documentation).
</para></listitem>
</orderedlist>
<para>
A good method for getting a feel for how much memory is
needed by your program is to allow the linker to set the memory size
to its usually conservative value. Then, if the program runs
with a variety of input satisfactorily but memory is limited on the
system, try reducing the allocation at the next compilation. If a
stack overflow occurs or an "ibrk()" call returns -1, then try
increasing the memory next time. You cannot damage the system by
getting it wrong, but data may be lost if the program runs out of
space at a crucial time. It pays to be in error on the generous
side.
</para>
</section>
</section>
</chapter>
